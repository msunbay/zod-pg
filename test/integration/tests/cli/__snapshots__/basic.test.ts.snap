// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`CLI generates correct zod schemas with basic options > constants.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export const MV_USER_POSTS = 'mv_user_posts';
export const TABLE_AUDIT_LOGS = 'audit_logs';
export const TABLE_CATEGORIES = 'categories';
export const TABLE_COMMENTS = 'comments';
export const TABLE_CONSTRAINT_VARIATIONS = 'constraint_variations';
export const TABLE_ENUM_TESTS = 'enum_tests';
export const TABLE_FILES = 'files';
export const TABLE_GEOGRAPHIC_DATA = 'geographic_data';
export const TABLE_INVENTORY = 'inventory';
export const TABLE_NETWORK_LOGS = 'network_logs';
export const TABLE_ORDER_ITEMS = 'order_items';
export const TABLE_ORDERS = 'orders';
export const TABLE_POST_CATEGORIES = 'post_categories';
export const TABLE_POSTS = 'posts';
export const TABLE_PRODUCTS = 'products';
export const TABLE_TIME_SERIES = 'time_series';
export const TABLE_USER_SESSIONS = 'user_sessions';
export const TABLE_USERS = 'users';
export const VIEW_USER_POSTS = 'view_user_posts';
"
`;

exports[`CLI generates correct zod schemas with basic options > materialized_views/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './mv_user_posts/index.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > materialized_views/mv_user_posts/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > materialized_views/mv_user_posts/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.mv_user_posts" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const MvUserPostsBaseSchema = z.object({
     /**
      * dataType: int4
      */
    user_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    user_name: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      */
    post_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    post_title: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    post_content: z.string().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.mv_user_posts" table.
 * This type represents the raw database record without case transforms.
 */
export type MvUserPostBaseRecord = z.output<typeof MvUserPostsBaseSchema>;

/**
 * Read transform for the "public.mv_user_posts" table.
 * Maps database fields to app case properties.
 */
export const transformMvUserPostBaseRecord = (data: MvUserPostBaseRecord): {
    userId?: MvUserPostBaseRecord['user_id'],
    userName?: MvUserPostBaseRecord['user_name'],
    postId?: MvUserPostBaseRecord['post_id'],
    postTitle?: MvUserPostBaseRecord['post_title'],
    postContent?: MvUserPostBaseRecord['post_content'],
} => ({
    userId: data.user_id,
    userName: data.user_name,
    postId: data.post_id,
    postTitle: data.post_title,
    postContent: data.post_content,
});

/**
 * Read schema for the "public.mv_user_posts" table (after casing transform).
 */
export const MvUserPostsSchema = MvUserPostsBaseSchema.transform(transformMvUserPostBaseRecord);

type TableReadRecord = z.output<typeof MvUserPostsSchema>;

/**
 * Read record (casing transformed) for the "public.mv_user_posts" materialized_view.
 */
export interface MvUserPostRecord {
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    userName?: TableReadRecord['userName'];
    /**
    */
    postId?: TableReadRecord['postId'];
    /**
    */
    postTitle?: TableReadRecord['postTitle'];
    /**
    */
    postContent?: TableReadRecord['postContent'];
}

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/audit_logs/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/audit_logs/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.audit_logs" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const AuditLogsTableBaseSchema = z.object({
     /**
      * dataType: int8
      * defaultValue: nextval('audit_logs_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: int4
      */
    user_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    action: z.string(),
     /**
      * dataType: varchar
      */
    table_name: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      */
    record_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: jsonb
      */
    old_values: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: jsonb
      */
    new_values: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.audit_logs" table.
 * This type represents the raw database record without case transforms.
 */
export type AuditLogBaseRecord = z.output<typeof AuditLogsTableBaseSchema>;

/**
 * Read transform for the "public.audit_logs" table.
 * Maps database fields to app case properties.
 */
export const transformAuditLogBaseRecord = (data: AuditLogBaseRecord): {
    id: AuditLogBaseRecord['id'],
    userId?: AuditLogBaseRecord['user_id'],
    action: AuditLogBaseRecord['action'],
    tableName?: AuditLogBaseRecord['table_name'],
    recordId?: AuditLogBaseRecord['record_id'],
    oldValues?: AuditLogBaseRecord['old_values'],
    newValues?: AuditLogBaseRecord['new_values'],
    createdAt?: AuditLogBaseRecord['created_at'],
} => ({
    id: data.id,
    userId: data.user_id,
    action: data.action,
    tableName: data.table_name,
    recordId: data.record_id,
    oldValues: data.old_values,
    newValues: data.new_values,
    createdAt: data.created_at,
});

/**
 * Read schema for the "public.audit_logs" table (after casing transform).
 */
export const AuditLogsTableSchema = AuditLogsTableBaseSchema.transform(transformAuditLogBaseRecord);

/**
 * Base insert/write schema for the "public.audit_logs" table (no casing transforms).
 */
export const AuditLogsTableInsertBaseSchema = z.object({
     /**
      * dataType: int4
      */
    userId: z.number().int().nullable().optional(),
     /**
      * dataType: varchar
      */
    action: z.string().max(50),
     /**
      * dataType: varchar
      */
    tableName: z.string().max(50).nullable().optional(),
     /**
      * dataType: int4
      */
    recordId: z.number().int().nullable().optional(),
     /**
      * dataType: jsonb
      */
    oldValues: z.any().nullable().transform((value) => value ? JSON.stringify(value) : value).optional(),
     /**
      * dataType: jsonb
      */
    newValues: z.any().nullable().transform((value) => value ? JSON.stringify(value) : value).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.audit_logs" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type AuditLogInsertBaseRecord = z.output<typeof AuditLogsTableInsertBaseSchema>;

/**
 * The base record type for the "public.audit_logs" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type AuditLogUpdateBaseRecord = Partial<AuditLogInsertBaseRecord>;

/**
 * Insert transform for the "public.audit_logs" table.
 * Maps app cased properties to database fields.
 */
export const transformAuditLogInsertBaseRecord = (data: AuditLogInsertBaseRecord): {
    user_id?: AuditLogInsertBaseRecord['userId'],
    action: AuditLogInsertBaseRecord['action'],
    table_name?: AuditLogInsertBaseRecord['tableName'],
    record_id?: AuditLogInsertBaseRecord['recordId'],
    old_values?: AuditLogInsertBaseRecord['oldValues'],
    new_values?: AuditLogInsertBaseRecord['newValues'],
    created_at?: AuditLogInsertBaseRecord['createdAt'],
} => ({
    user_id: data.userId,
    action: data.action,
    table_name: data.tableName,
    record_id: data.recordId,
    old_values: data.oldValues,
    new_values: data.newValues,
    created_at: data.createdAt,
});

/**
 * Update transform for the "public.audit_logs" table.
 * Maps app cased properties to database fields.
 */
export const transformAuditLogUpdateBaseRecord = (data: AuditLogUpdateBaseRecord): {
    user_id?: AuditLogUpdateBaseRecord['userId'],
    action: AuditLogUpdateBaseRecord['action'],
    table_name?: AuditLogUpdateBaseRecord['tableName'],
    record_id?: AuditLogUpdateBaseRecord['recordId'],
    old_values?: AuditLogUpdateBaseRecord['oldValues'],
    new_values?: AuditLogUpdateBaseRecord['newValues'],
    created_at?: AuditLogUpdateBaseRecord['createdAt'],
} => ({
    user_id: data.userId,
    action: data.action,
    table_name: data.tableName,
    record_id: data.recordId,
    old_values: data.oldValues,
    new_values: data.newValues,
    created_at: data.createdAt,
});

/**
 * Insert schema for the "public.audit_logs" table (after casing transform).
 */
export const AuditLogsTableInsertSchema = AuditLogsTableInsertBaseSchema.transform(transformAuditLogInsertBaseRecord);

/**
 * Update schema for the "public.audit_logs" table (after casing transform).
 */
export const AuditLogsTableUpdateSchema = AuditLogsTableInsertBaseSchema.partial().transform(transformAuditLogUpdateBaseRecord);

type TableInsertRecord = z.input<typeof AuditLogsTableInsertSchema>;
type TableReadRecord = z.output<typeof AuditLogsTableSchema>;

/**
 * Read record (casing transformed) for the "public.audit_logs" table.
 */
export interface AuditLogRecord {
    /**
    * Primary key for audit logs table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the user who performed the action
    */
    userId?: TableReadRecord['userId'];
    /**
    * Type of action performed
    */
    action: TableReadRecord['action'];
    /**
    * Name of the table affected
    */
    tableName?: TableReadRecord['tableName'];
    /**
    * ID of the record affected
    */
    recordId?: TableReadRecord['recordId'];
    /**
    * Previous values before the change
    */
    oldValues?: TableReadRecord['oldValues'];
    /**
    * New values after the change
    */
    newValues?: TableReadRecord['newValues'];
    /**
    * Timestamp when the action was performed
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
 * Insert record (casing transformed) for the "public.audit_logs" table.
 */
export interface AuditLogInsertRecord {
    /**
    * ID of the user who performed the action
    */
    userId?: TableInsertRecord['userId'];
    /**
    * Type of action performed
    * @maxLen: 50
    */
    action: TableInsertRecord['action'];
    /**
    * Name of the table affected
    * @maxLen: 50
    */
    tableName?: TableInsertRecord['tableName'];
    /**
    * ID of the record affected
    */
    recordId?: TableInsertRecord['recordId'];
    /**
    * Previous values before the change
    */
    oldValues?: TableInsertRecord['oldValues'];
    /**
    * New values after the change
    */
    newValues?: TableInsertRecord['newValues'];
    /**
    * Timestamp when the action was performed
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
 * Updatable record (casing transformed) for the "public.audit_logs" table.
 */
export type AuditLogUpdateRecord = Partial<AuditLogInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/categories/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/categories/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.categories" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const CategoriesTableBaseSchema = z.object({
     /**
      * dataType: int4
      * defaultValue: nextval('categories_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: varchar
      */
    name: z.string(),
     /**
      * dataType: text
      */
    description: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    color: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.categories" table.
 * This type represents the raw database record without case transforms.
 */
export type CategoryBaseRecord = z.output<typeof CategoriesTableBaseSchema>;

/**
 * Read transform for the "public.categories" table.
 * Maps database fields to app case properties.
 */
export const transformCategoryBaseRecord = (data: CategoryBaseRecord): {
    id: CategoryBaseRecord['id'],
    name: CategoryBaseRecord['name'],
    description?: CategoryBaseRecord['description'],
    color?: CategoryBaseRecord['color'],
    createdAt?: CategoryBaseRecord['created_at'],
} => ({
    id: data.id,
    name: data.name,
    description: data.description,
    color: data.color,
    createdAt: data.created_at,
});

/**
 * Read schema for the "public.categories" table (after casing transform).
 */
export const CategoriesTableSchema = CategoriesTableBaseSchema.transform(transformCategoryBaseRecord);

/**
 * Base insert/write schema for the "public.categories" table (no casing transforms).
 */
export const CategoriesTableInsertBaseSchema = z.object({
     /**
      * dataType: varchar
      */
    name: z.string().max(100),
     /**
      * dataType: text
      */
    description: z.string().nullable().optional(),
     /**
      * dataType: varchar
      */
    color: z.string().max(7).nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.categories" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type CategoryInsertBaseRecord = z.output<typeof CategoriesTableInsertBaseSchema>;

/**
 * The base record type for the "public.categories" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type CategoryUpdateBaseRecord = Partial<CategoryInsertBaseRecord>;

/**
 * Insert transform for the "public.categories" table.
 * Maps app cased properties to database fields.
 */
export const transformCategoryInsertBaseRecord = (data: CategoryInsertBaseRecord): {
    name: CategoryInsertBaseRecord['name'],
    description?: CategoryInsertBaseRecord['description'],
    color?: CategoryInsertBaseRecord['color'],
    created_at?: CategoryInsertBaseRecord['createdAt'],
} => ({
    name: data.name,
    description: data.description,
    color: data.color,
    created_at: data.createdAt,
});

/**
 * Update transform for the "public.categories" table.
 * Maps app cased properties to database fields.
 */
export const transformCategoryUpdateBaseRecord = (data: CategoryUpdateBaseRecord): {
    name: CategoryUpdateBaseRecord['name'],
    description?: CategoryUpdateBaseRecord['description'],
    color?: CategoryUpdateBaseRecord['color'],
    created_at?: CategoryUpdateBaseRecord['createdAt'],
} => ({
    name: data.name,
    description: data.description,
    color: data.color,
    created_at: data.createdAt,
});

/**
 * Insert schema for the "public.categories" table (after casing transform).
 */
export const CategoriesTableInsertSchema = CategoriesTableInsertBaseSchema.transform(transformCategoryInsertBaseRecord);

/**
 * Update schema for the "public.categories" table (after casing transform).
 */
export const CategoriesTableUpdateSchema = CategoriesTableInsertBaseSchema.partial().transform(transformCategoryUpdateBaseRecord);

type TableInsertRecord = z.input<typeof CategoriesTableInsertSchema>;
type TableReadRecord = z.output<typeof CategoriesTableSchema>;

/**
 * Read record (casing transformed) for the "public.categories" table.
 */
export interface CategoryRecord {
    /**
    * Primary key for categories table
    */
    id: TableReadRecord['id'];
    /**
    * Name of the category
    */
    name: TableReadRecord['name'];
    /**
    * Description of the category
    */
    description?: TableReadRecord['description'];
    /**
    * Hex color code for the category
    */
    color?: TableReadRecord['color'];
    /**
    * Timestamp when the category was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
 * Insert record (casing transformed) for the "public.categories" table.
 */
export interface CategoryInsertRecord {
    /**
    * Name of the category
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * Description of the category
    */
    description?: TableInsertRecord['description'];
    /**
    * Hex color code for the category
    * @maxLen: 7
    */
    color?: TableInsertRecord['color'];
    /**
    * Timestamp when the category was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
 * Updatable record (casing transformed) for the "public.categories" table.
 */
export type CategoryUpdateRecord = Partial<CategoryInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/comments/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/comments/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.comments" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const CommentsTableBaseSchema = z.object({
     /**
      * dataType: int4
      * defaultValue: nextval('comments_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: int4
      */
    post_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      */
    user_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      */
    parent_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    content: z.string(),
     /**
      * dataType: bool
      * defaultValue: false
      */
    is_approved: z.boolean().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    updated_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.comments" table.
 * This type represents the raw database record without case transforms.
 */
export type CommentBaseRecord = z.output<typeof CommentsTableBaseSchema>;

/**
 * Read transform for the "public.comments" table.
 * Maps database fields to app case properties.
 */
export const transformCommentBaseRecord = (data: CommentBaseRecord): {
    id: CommentBaseRecord['id'],
    postId?: CommentBaseRecord['post_id'],
    userId?: CommentBaseRecord['user_id'],
    parentId?: CommentBaseRecord['parent_id'],
    content: CommentBaseRecord['content'],
    isApproved?: CommentBaseRecord['is_approved'],
    createdAt?: CommentBaseRecord['created_at'],
    updatedAt?: CommentBaseRecord['updated_at'],
} => ({
    id: data.id,
    postId: data.post_id,
    userId: data.user_id,
    parentId: data.parent_id,
    content: data.content,
    isApproved: data.is_approved,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
});

/**
 * Read schema for the "public.comments" table (after casing transform).
 */
export const CommentsTableSchema = CommentsTableBaseSchema.transform(transformCommentBaseRecord);

/**
 * Base insert/write schema for the "public.comments" table (no casing transforms).
 */
export const CommentsTableInsertBaseSchema = z.object({
     /**
      * dataType: int4
      */
    postId: z.number().int().nullable().optional(),
     /**
      * dataType: int4
      */
    userId: z.number().int().nullable().optional(),
     /**
      * dataType: int4
      */
    parentId: z.number().int().nullable().optional(),
     /**
      * dataType: text
      */
    content: z.string(),
     /**
      * dataType: bool
      * defaultValue: false
      */
    isApproved: z.boolean().nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    updatedAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.comments" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type CommentInsertBaseRecord = z.output<typeof CommentsTableInsertBaseSchema>;

/**
 * The base record type for the "public.comments" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type CommentUpdateBaseRecord = Partial<CommentInsertBaseRecord>;

/**
 * Insert transform for the "public.comments" table.
 * Maps app cased properties to database fields.
 */
export const transformCommentInsertBaseRecord = (data: CommentInsertBaseRecord): {
    post_id?: CommentInsertBaseRecord['postId'],
    user_id?: CommentInsertBaseRecord['userId'],
    parent_id?: CommentInsertBaseRecord['parentId'],
    content: CommentInsertBaseRecord['content'],
    is_approved?: CommentInsertBaseRecord['isApproved'],
    created_at?: CommentInsertBaseRecord['createdAt'],
    updated_at?: CommentInsertBaseRecord['updatedAt'],
} => ({
    post_id: data.postId,
    user_id: data.userId,
    parent_id: data.parentId,
    content: data.content,
    is_approved: data.isApproved,
    created_at: data.createdAt,
    updated_at: data.updatedAt,
});

/**
 * Update transform for the "public.comments" table.
 * Maps app cased properties to database fields.
 */
export const transformCommentUpdateBaseRecord = (data: CommentUpdateBaseRecord): {
    post_id?: CommentUpdateBaseRecord['postId'],
    user_id?: CommentUpdateBaseRecord['userId'],
    parent_id?: CommentUpdateBaseRecord['parentId'],
    content: CommentUpdateBaseRecord['content'],
    is_approved?: CommentUpdateBaseRecord['isApproved'],
    created_at?: CommentUpdateBaseRecord['createdAt'],
    updated_at?: CommentUpdateBaseRecord['updatedAt'],
} => ({
    post_id: data.postId,
    user_id: data.userId,
    parent_id: data.parentId,
    content: data.content,
    is_approved: data.isApproved,
    created_at: data.createdAt,
    updated_at: data.updatedAt,
});

/**
 * Insert schema for the "public.comments" table (after casing transform).
 */
export const CommentsTableInsertSchema = CommentsTableInsertBaseSchema.transform(transformCommentInsertBaseRecord);

/**
 * Update schema for the "public.comments" table (after casing transform).
 */
export const CommentsTableUpdateSchema = CommentsTableInsertBaseSchema.partial().transform(transformCommentUpdateBaseRecord);

type TableInsertRecord = z.input<typeof CommentsTableInsertSchema>;
type TableReadRecord = z.output<typeof CommentsTableSchema>;

/**
 * Read record (casing transformed) for the "public.comments" table.
 */
export interface CommentRecord {
    /**
    * Primary key for comments table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the post this comment belongs to
    */
    postId?: TableReadRecord['postId'];
    /**
    * ID of the user who wrote the comment
    */
    userId?: TableReadRecord['userId'];
    /**
    * ID of the parent comment for nested comments
    */
    parentId?: TableReadRecord['parentId'];
    /**
    * Content of the comment
    */
    content: TableReadRecord['content'];
    /**
    * Whether the comment has been approved by moderators
    */
    isApproved?: TableReadRecord['isApproved'];
    /**
    * Timestamp when the comment was created
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    * Timestamp when the comment was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
 * Insert record (casing transformed) for the "public.comments" table.
 */
export interface CommentInsertRecord {
    /**
    * ID of the post this comment belongs to
    */
    postId?: TableInsertRecord['postId'];
    /**
    * ID of the user who wrote the comment
    */
    userId?: TableInsertRecord['userId'];
    /**
    * ID of the parent comment for nested comments
    */
    parentId?: TableInsertRecord['parentId'];
    /**
    * Content of the comment
    */
    content: TableInsertRecord['content'];
    /**
    * Whether the comment has been approved by moderators
    * @default: false
    */
    isApproved?: TableInsertRecord['isApproved'];
    /**
    * Timestamp when the comment was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    * Timestamp when the comment was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
 * Updatable record (casing transformed) for the "public.comments" table.
 */
export type CommentUpdateRecord = Partial<CommentInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/constraint_variations/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/constraint_variations/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';

export const CONSTRAINT_VARIATION_ANIMALS = ['cat', 'dog', 'bird', 'fish'] as const;
export const CONSTRAINT_VARIATION_FRUITS = ['apple', 'banana', 'orange', 'grape'] as const;
export const CONSTRAINT_VARIATION_VEHICLES = ['car', 'truck', 'motorcycle', 'bicycle'] as const;
export const CONSTRAINT_VARIATION_LANGUAGES = ['en', 'es', 'fr', 'de', 'it'] as const;
export const CONSTRAINT_VARIATION_ACTIVE_STATUSES = ['true', 'false'] as const;

/**
 * Base read schema for the "public.constraint_variations" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const ConstraintVariationsTableBaseSchema = z.object({
     /**
      * dataType: int4
      * defaultValue: nextval('constraint_variations_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: varchar
      */
    animal: z.enum(CONSTRAINT_VARIATION_ANIMALS).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    fruit: z.enum(CONSTRAINT_VARIATION_FRUITS).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    vehicle: z.enum(CONSTRAINT_VARIATION_VEHICLES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bpchar
      */
    language: z.enum(CONSTRAINT_VARIATION_LANGUAGES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int2
      */
    rating: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bool
      */
    active_status: z.enum(CONSTRAINT_VARIATION_ACTIVE_STATUSES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.constraint_variations" table.
 * This type represents the raw database record without case transforms.
 */
export type ConstraintVariationBaseRecord = z.output<typeof ConstraintVariationsTableBaseSchema>;

/**
 * Read transform for the "public.constraint_variations" table.
 * Maps database fields to app case properties.
 */
export const transformConstraintVariationBaseRecord = (data: ConstraintVariationBaseRecord): {
    id: ConstraintVariationBaseRecord['id'],
    animal?: ConstraintVariationBaseRecord['animal'],
    fruit?: ConstraintVariationBaseRecord['fruit'],
    vehicle?: ConstraintVariationBaseRecord['vehicle'],
    language?: ConstraintVariationBaseRecord['language'],
    rating?: ConstraintVariationBaseRecord['rating'],
    activeStatus?: ConstraintVariationBaseRecord['active_status'],
    createdAt?: ConstraintVariationBaseRecord['created_at'],
} => ({
    id: data.id,
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    activeStatus: data.active_status,
    createdAt: data.created_at,
});

/**
 * Read schema for the "public.constraint_variations" table (after casing transform).
 */
export const ConstraintVariationsTableSchema = ConstraintVariationsTableBaseSchema.transform(transformConstraintVariationBaseRecord);

/**
 * Base insert/write schema for the "public.constraint_variations" table (no casing transforms).
 */
export const ConstraintVariationsTableInsertBaseSchema = z.object({
     /**
      * dataType: varchar
      */
    animal: z.enum(CONSTRAINT_VARIATION_ANIMALS).nullable().optional(),
     /**
      * dataType: text
      */
    fruit: z.enum(CONSTRAINT_VARIATION_FRUITS).nullable().optional(),
     /**
      * dataType: varchar
      */
    vehicle: z.enum(CONSTRAINT_VARIATION_VEHICLES).nullable().optional(),
     /**
      * dataType: bpchar
      */
    language: z.enum(CONSTRAINT_VARIATION_LANGUAGES).nullable().optional(),
     /**
      * dataType: int2
      */
    rating: z.number().int().nullable().optional(),
     /**
      * dataType: bool
      */
    activeStatus: z.enum(CONSTRAINT_VARIATION_ACTIVE_STATUSES).nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.constraint_variations" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type ConstraintVariationInsertBaseRecord = z.output<typeof ConstraintVariationsTableInsertBaseSchema>;

/**
 * The base record type for the "public.constraint_variations" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type ConstraintVariationUpdateBaseRecord = Partial<ConstraintVariationInsertBaseRecord>;

/**
 * Insert transform for the "public.constraint_variations" table.
 * Maps app cased properties to database fields.
 */
export const transformConstraintVariationInsertBaseRecord = (data: ConstraintVariationInsertBaseRecord): {
    animal?: ConstraintVariationInsertBaseRecord['animal'],
    fruit?: ConstraintVariationInsertBaseRecord['fruit'],
    vehicle?: ConstraintVariationInsertBaseRecord['vehicle'],
    language?: ConstraintVariationInsertBaseRecord['language'],
    rating?: ConstraintVariationInsertBaseRecord['rating'],
    active_status?: ConstraintVariationInsertBaseRecord['activeStatus'],
    created_at?: ConstraintVariationInsertBaseRecord['createdAt'],
} => ({
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    active_status: data.activeStatus,
    created_at: data.createdAt,
});

/**
 * Update transform for the "public.constraint_variations" table.
 * Maps app cased properties to database fields.
 */
export const transformConstraintVariationUpdateBaseRecord = (data: ConstraintVariationUpdateBaseRecord): {
    animal?: ConstraintVariationUpdateBaseRecord['animal'],
    fruit?: ConstraintVariationUpdateBaseRecord['fruit'],
    vehicle?: ConstraintVariationUpdateBaseRecord['vehicle'],
    language?: ConstraintVariationUpdateBaseRecord['language'],
    rating?: ConstraintVariationUpdateBaseRecord['rating'],
    active_status?: ConstraintVariationUpdateBaseRecord['activeStatus'],
    created_at?: ConstraintVariationUpdateBaseRecord['createdAt'],
} => ({
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    active_status: data.activeStatus,
    created_at: data.createdAt,
});

/**
 * Insert schema for the "public.constraint_variations" table (after casing transform).
 */
export const ConstraintVariationsTableInsertSchema = ConstraintVariationsTableInsertBaseSchema.transform(transformConstraintVariationInsertBaseRecord);

/**
 * Update schema for the "public.constraint_variations" table (after casing transform).
 */
export const ConstraintVariationsTableUpdateSchema = ConstraintVariationsTableInsertBaseSchema.partial().transform(transformConstraintVariationUpdateBaseRecord);

type TableInsertRecord = z.input<typeof ConstraintVariationsTableInsertSchema>;
type TableReadRecord = z.output<typeof ConstraintVariationsTableSchema>;

/**
 * Read record (casing transformed) for the "public.constraint_variations" table.
 */
export interface ConstraintVariationRecord {
    /**
    * Primary key for constraint variations table
    */
    id: TableReadRecord['id'];
    /**
    * Type of animal
    */
    animal?: TableReadRecord['animal'];
    /**
    * Type of fruit
    */
    fruit?: TableReadRecord['fruit'];
    /**
    * Type of vehicle
    */
    vehicle?: TableReadRecord['vehicle'];
    /**
    * Language code
    */
    language?: TableReadRecord['language'];
    /**
    * Rating score (1-5)
    */
    rating?: TableReadRecord['rating'];
    /**
    * Whether the item is active
    */
    activeStatus?: TableReadRecord['activeStatus'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
 * Insert record (casing transformed) for the "public.constraint_variations" table.
 */
export interface ConstraintVariationInsertRecord {
    /**
    * Type of animal
    * @maxLen: 20
    */
    animal?: TableInsertRecord['animal'];
    /**
    * Type of fruit
    */
    fruit?: TableInsertRecord['fruit'];
    /**
    * Type of vehicle
    * @maxLen: 15
    */
    vehicle?: TableInsertRecord['vehicle'];
    /**
    * Language code
    * @maxLen: 2
    */
    language?: TableInsertRecord['language'];
    /**
    * Rating score (1-5)
    */
    rating?: TableInsertRecord['rating'];
    /**
    * Whether the item is active
    */
    activeStatus?: TableInsertRecord['activeStatus'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
 * Updatable record (casing transformed) for the "public.constraint_variations" table.
 */
export type ConstraintVariationUpdateRecord = Partial<ConstraintVariationInsertRecord>;

export type ConstraintVariationAnimal = (typeof CONSTRAINT_VARIATION_ANIMALS)[number];
export type ConstraintVariationFruit = (typeof CONSTRAINT_VARIATION_FRUITS)[number];
export type ConstraintVariationVehicle = (typeof CONSTRAINT_VARIATION_VEHICLES)[number];
export type ConstraintVariationLanguage = (typeof CONSTRAINT_VARIATION_LANGUAGES)[number];
export type ConstraintVariationActiveStatus = (typeof CONSTRAINT_VARIATION_ACTIVE_STATUSES)[number];
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/enum_tests/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/enum_tests/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';

export const ENUM_TEST_PRIORITIES = ['low', 'medium', 'high', 'critical'] as const;
export const ENUM_TEST_COLORS = ['red', 'green', 'blue', 'yellow'] as const;
export const ENUM_TEST_SIZES = ['xs', 's', 'm', 'l', 'xl', 'xxl'] as const;
export const ENUM_TEST_GRADES = ['A', 'B', 'C', 'D', 'F'] as const;
export const ENUM_TEST_CATEGORIES = ['electronics', 'clothing', 'books', 'home-garden'] as const;
export const ENUM_TEST_MOODS = ['happy', 'sad', 'angry', 'excited', 'calm'] as const;
export const ENUM_TEST_DIRECTIONS = ['north', 'south', 'east', 'west'] as const;
export const ENUM_TEST_WEATHER_CONDITIONS = ['sunny', 'cloudy', 'rainy', 'snowy', 'foggy'] as const;
export const ENUM_TEST_TASK_STATUSES = ['todo', 'in-progress', 'done', 'cancelled'] as const;
export const ENUM_TEST_DIFFICULTIES = ['1', '2', '3', '4', '5'] as const;
export const ENUM_TEST_WEEKDAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as const;
export const ENUM_TEST_PAYMENT_METHODS = ['cash', 'credit-card', 'debit-card', 'paypal', 'bank-transfer'] as const;

/**
 * Base read schema for the "public.enum_tests" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const EnumTestsTableBaseSchema = z.object({
     /**
      * dataType: int4
      * defaultValue: nextval('enum_tests_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: varchar
      */
    priority: z.enum(ENUM_TEST_PRIORITIES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    color: z.enum(ENUM_TEST_COLORS).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    size: z.enum(ENUM_TEST_SIZES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bpchar
      */
    grade: z.enum(ENUM_TEST_GRADES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    category: z.enum(ENUM_TEST_CATEGORIES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    mood: z.enum(ENUM_TEST_MOODS).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    direction: z.enum(ENUM_TEST_DIRECTIONS).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    weather_condition: z.enum(ENUM_TEST_WEATHER_CONDITIONS).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    task_status: z.enum(ENUM_TEST_TASK_STATUSES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      */
    difficulty: z.enum(ENUM_TEST_DIFFICULTIES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    weekday: z.enum(ENUM_TEST_WEEKDAYS).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    payment_method: z.enum(ENUM_TEST_PAYMENT_METHODS).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.enum_tests" table.
 * This type represents the raw database record without case transforms.
 */
export type EnumTestBaseRecord = z.output<typeof EnumTestsTableBaseSchema>;

/**
 * Read transform for the "public.enum_tests" table.
 * Maps database fields to app case properties.
 */
export const transformEnumTestBaseRecord = (data: EnumTestBaseRecord): {
    id: EnumTestBaseRecord['id'],
    priority?: EnumTestBaseRecord['priority'],
    color?: EnumTestBaseRecord['color'],
    size?: EnumTestBaseRecord['size'],
    grade?: EnumTestBaseRecord['grade'],
    category?: EnumTestBaseRecord['category'],
    mood?: EnumTestBaseRecord['mood'],
    direction?: EnumTestBaseRecord['direction'],
    weatherCondition?: EnumTestBaseRecord['weather_condition'],
    taskStatus?: EnumTestBaseRecord['task_status'],
    difficulty?: EnumTestBaseRecord['difficulty'],
    weekday?: EnumTestBaseRecord['weekday'],
    paymentMethod?: EnumTestBaseRecord['payment_method'],
    createdAt?: EnumTestBaseRecord['created_at'],
} => ({
    id: data.id,
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weatherCondition: data.weather_condition,
    taskStatus: data.task_status,
    difficulty: data.difficulty,
    weekday: data.weekday,
    paymentMethod: data.payment_method,
    createdAt: data.created_at,
});

/**
 * Read schema for the "public.enum_tests" table (after casing transform).
 */
export const EnumTestsTableSchema = EnumTestsTableBaseSchema.transform(transformEnumTestBaseRecord);

/**
 * Base insert/write schema for the "public.enum_tests" table (no casing transforms).
 */
export const EnumTestsTableInsertBaseSchema = z.object({
     /**
      * dataType: varchar
      */
    priority: z.enum(ENUM_TEST_PRIORITIES).nullable().optional(),
     /**
      * dataType: varchar
      */
    color: z.enum(ENUM_TEST_COLORS).nullable().optional(),
     /**
      * dataType: text
      */
    size: z.enum(ENUM_TEST_SIZES).nullable().optional(),
     /**
      * dataType: bpchar
      */
    grade: z.enum(ENUM_TEST_GRADES).nullable().optional(),
     /**
      * dataType: varchar
      */
    category: z.enum(ENUM_TEST_CATEGORIES).nullable().optional(),
     /**
      * dataType: text
      */
    mood: z.enum(ENUM_TEST_MOODS).nullable().optional(),
     /**
      * dataType: varchar
      */
    direction: z.enum(ENUM_TEST_DIRECTIONS).nullable().optional(),
     /**
      * dataType: text
      */
    weatherCondition: z.enum(ENUM_TEST_WEATHER_CONDITIONS).nullable().optional(),
     /**
      * dataType: varchar
      */
    taskStatus: z.enum(ENUM_TEST_TASK_STATUSES).nullable().optional(),
     /**
      * dataType: int4
      */
    difficulty: z.enum(ENUM_TEST_DIFFICULTIES).nullable().optional(),
     /**
      * dataType: varchar
      */
    weekday: z.enum(ENUM_TEST_WEEKDAYS).nullable().optional(),
     /**
      * dataType: text
      */
    paymentMethod: z.enum(ENUM_TEST_PAYMENT_METHODS).nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.enum_tests" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type EnumTestInsertBaseRecord = z.output<typeof EnumTestsTableInsertBaseSchema>;

/**
 * The base record type for the "public.enum_tests" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type EnumTestUpdateBaseRecord = Partial<EnumTestInsertBaseRecord>;

/**
 * Insert transform for the "public.enum_tests" table.
 * Maps app cased properties to database fields.
 */
export const transformEnumTestInsertBaseRecord = (data: EnumTestInsertBaseRecord): {
    priority?: EnumTestInsertBaseRecord['priority'],
    color?: EnumTestInsertBaseRecord['color'],
    size?: EnumTestInsertBaseRecord['size'],
    grade?: EnumTestInsertBaseRecord['grade'],
    category?: EnumTestInsertBaseRecord['category'],
    mood?: EnumTestInsertBaseRecord['mood'],
    direction?: EnumTestInsertBaseRecord['direction'],
    weather_condition?: EnumTestInsertBaseRecord['weatherCondition'],
    task_status?: EnumTestInsertBaseRecord['taskStatus'],
    difficulty?: EnumTestInsertBaseRecord['difficulty'],
    weekday?: EnumTestInsertBaseRecord['weekday'],
    payment_method?: EnumTestInsertBaseRecord['paymentMethod'],
    created_at?: EnumTestInsertBaseRecord['createdAt'],
} => ({
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weather_condition: data.weatherCondition,
    task_status: data.taskStatus,
    difficulty: data.difficulty,
    weekday: data.weekday,
    payment_method: data.paymentMethod,
    created_at: data.createdAt,
});

/**
 * Update transform for the "public.enum_tests" table.
 * Maps app cased properties to database fields.
 */
export const transformEnumTestUpdateBaseRecord = (data: EnumTestUpdateBaseRecord): {
    priority?: EnumTestUpdateBaseRecord['priority'],
    color?: EnumTestUpdateBaseRecord['color'],
    size?: EnumTestUpdateBaseRecord['size'],
    grade?: EnumTestUpdateBaseRecord['grade'],
    category?: EnumTestUpdateBaseRecord['category'],
    mood?: EnumTestUpdateBaseRecord['mood'],
    direction?: EnumTestUpdateBaseRecord['direction'],
    weather_condition?: EnumTestUpdateBaseRecord['weatherCondition'],
    task_status?: EnumTestUpdateBaseRecord['taskStatus'],
    difficulty?: EnumTestUpdateBaseRecord['difficulty'],
    weekday?: EnumTestUpdateBaseRecord['weekday'],
    payment_method?: EnumTestUpdateBaseRecord['paymentMethod'],
    created_at?: EnumTestUpdateBaseRecord['createdAt'],
} => ({
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weather_condition: data.weatherCondition,
    task_status: data.taskStatus,
    difficulty: data.difficulty,
    weekday: data.weekday,
    payment_method: data.paymentMethod,
    created_at: data.createdAt,
});

/**
 * Insert schema for the "public.enum_tests" table (after casing transform).
 */
export const EnumTestsTableInsertSchema = EnumTestsTableInsertBaseSchema.transform(transformEnumTestInsertBaseRecord);

/**
 * Update schema for the "public.enum_tests" table (after casing transform).
 */
export const EnumTestsTableUpdateSchema = EnumTestsTableInsertBaseSchema.partial().transform(transformEnumTestUpdateBaseRecord);

type TableInsertRecord = z.input<typeof EnumTestsTableInsertSchema>;
type TableReadRecord = z.output<typeof EnumTestsTableSchema>;

/**
 * Read record (casing transformed) for the "public.enum_tests" table.
 */
export interface EnumTestRecord {
    /**
    * Primary key for enum tests table
    */
    id: TableReadRecord['id'];
    /**
    * Task priority level
    */
    priority?: TableReadRecord['priority'];
    /**
    * Color selection
    */
    color?: TableReadRecord['color'];
    /**
    * Size option
    */
    size?: TableReadRecord['size'];
    /**
    * Letter grade
    */
    grade?: TableReadRecord['grade'];
    /**
    * Product category
    */
    category?: TableReadRecord['category'];
    /**
    * Current mood state
    */
    mood?: TableReadRecord['mood'];
    /**
    * Compass direction
    */
    direction?: TableReadRecord['direction'];
    /**
    * Current weather condition
    */
    weatherCondition?: TableReadRecord['weatherCondition'];
    /**
    * Status of the task
    */
    taskStatus?: TableReadRecord['taskStatus'];
    /**
    * Difficulty level (1-5)
    */
    difficulty?: TableReadRecord['difficulty'];
    /**
    * Day of the week
    */
    weekday?: TableReadRecord['weekday'];
    /**
    * Payment method used
    */
    paymentMethod?: TableReadRecord['paymentMethod'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
 * Insert record (casing transformed) for the "public.enum_tests" table.
 */
export interface EnumTestInsertRecord {
    /**
    * Task priority level
    * @maxLen: 10
    */
    priority?: TableInsertRecord['priority'];
    /**
    * Color selection
    * @maxLen: 20
    */
    color?: TableInsertRecord['color'];
    /**
    * Size option
    */
    size?: TableInsertRecord['size'];
    /**
    * Letter grade
    * @maxLen: 1
    */
    grade?: TableInsertRecord['grade'];
    /**
    * Product category
    * @maxLen: 30
    */
    category?: TableInsertRecord['category'];
    /**
    * Current mood state
    */
    mood?: TableInsertRecord['mood'];
    /**
    * Compass direction
    * @maxLen: 10
    */
    direction?: TableInsertRecord['direction'];
    /**
    * Current weather condition
    */
    weatherCondition?: TableInsertRecord['weatherCondition'];
    /**
    * Status of the task
    * @maxLen: 20
    */
    taskStatus?: TableInsertRecord['taskStatus'];
    /**
    * Difficulty level (1-5)
    */
    difficulty?: TableInsertRecord['difficulty'];
    /**
    * Day of the week
    * @maxLen: 10
    */
    weekday?: TableInsertRecord['weekday'];
    /**
    * Payment method used
    */
    paymentMethod?: TableInsertRecord['paymentMethod'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
 * Updatable record (casing transformed) for the "public.enum_tests" table.
 */
export type EnumTestUpdateRecord = Partial<EnumTestInsertRecord>;

export type EnumTestPriority = (typeof ENUM_TEST_PRIORITIES)[number];
export type EnumTestColor = (typeof ENUM_TEST_COLORS)[number];
export type EnumTestSize = (typeof ENUM_TEST_SIZES)[number];
export type EnumTestGrade = (typeof ENUM_TEST_GRADES)[number];
export type EnumTestCategory = (typeof ENUM_TEST_CATEGORIES)[number];
export type EnumTestMood = (typeof ENUM_TEST_MOODS)[number];
export type EnumTestDirection = (typeof ENUM_TEST_DIRECTIONS)[number];
export type EnumTestWeatherCondition = (typeof ENUM_TEST_WEATHER_CONDITIONS)[number];
export type EnumTestTaskStatus = (typeof ENUM_TEST_TASK_STATUSES)[number];
export type EnumTestDifficulty = (typeof ENUM_TEST_DIFFICULTIES)[number];
export type EnumTestWeekday = (typeof ENUM_TEST_WEEKDAYS)[number];
export type EnumTestPaymentMethod = (typeof ENUM_TEST_PAYMENT_METHODS)[number];
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/files/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/files/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.files" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const FilesTableBaseSchema = z.object({
     /**
      * dataType: uuid
      * defaultValue: gen_random_uuid()
      */
    id: z.string(),
     /**
      * dataType: varchar
      */
    filename: z.string(),
     /**
      * dataType: text
      */
    file_path: z.string(),
     /**
      * dataType: int8
      */
    file_size: z.number(),
     /**
      * dataType: varchar
      */
    mime_type: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bpchar
      */
    checksum: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bytea
      */
    binary_data: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bool
      * defaultValue: false
      */
    is_encrypted: z.boolean().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    upload_time: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      */
    expiry_date: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: jsonb
      */
    metadata: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: _text
      */
    tags: z.array(z.string()).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      * defaultValue: 0
      */
    access_count: z.number().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.files" table.
 * This type represents the raw database record without case transforms.
 */
export type FileBaseRecord = z.output<typeof FilesTableBaseSchema>;

/**
 * Read transform for the "public.files" table.
 * Maps database fields to app case properties.
 */
export const transformFileBaseRecord = (data: FileBaseRecord): {
    id: FileBaseRecord['id'],
    filename: FileBaseRecord['filename'],
    filePath: FileBaseRecord['file_path'],
    fileSize: FileBaseRecord['file_size'],
    mimeType?: FileBaseRecord['mime_type'],
    checksum?: FileBaseRecord['checksum'],
    binaryData?: FileBaseRecord['binary_data'],
    isEncrypted?: FileBaseRecord['is_encrypted'],
    uploadTime?: FileBaseRecord['upload_time'],
    expiryDate?: FileBaseRecord['expiry_date'],
    metadata?: FileBaseRecord['metadata'],
    tags?: FileBaseRecord['tags'],
    accessCount?: FileBaseRecord['access_count'],
} => ({
    id: data.id,
    filename: data.filename,
    filePath: data.file_path,
    fileSize: data.file_size,
    mimeType: data.mime_type,
    checksum: data.checksum,
    binaryData: data.binary_data,
    isEncrypted: data.is_encrypted,
    uploadTime: data.upload_time,
    expiryDate: data.expiry_date,
    metadata: data.metadata,
    tags: data.tags,
    accessCount: data.access_count,
});

/**
 * Read schema for the "public.files" table (after casing transform).
 */
export const FilesTableSchema = FilesTableBaseSchema.transform(transformFileBaseRecord);

/**
 * Base insert/write schema for the "public.files" table (no casing transforms).
 */
export const FilesTableInsertBaseSchema = z.object({
     /**
      * dataType: uuid
      * defaultValue: gen_random_uuid()
      */
    id: z.string().uuid().optional(),
     /**
      * dataType: varchar
      */
    filename: z.string().max(255),
     /**
      * dataType: text
      */
    filePath: z.string(),
     /**
      * dataType: int8
      */
    fileSize: z.number().int(),
     /**
      * dataType: varchar
      */
    mimeType: z.string().max(100).nullable().optional(),
     /**
      * dataType: bpchar
      */
    checksum: z.string().max(64).nullable().optional(),
     /**
      * dataType: bytea
      */
    binaryData: z.string().nullable().optional(),
     /**
      * dataType: bool
      * defaultValue: false
      */
    isEncrypted: z.boolean().nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    uploadTime: z.date().nullable().optional(),
     /**
      * dataType: timestamptz
      */
    expiryDate: z.date().nullable().optional(),
     /**
      * dataType: jsonb
      */
    metadata: z.any().nullable().transform((value) => value ? JSON.stringify(value) : value).optional(),
     /**
      * dataType: _text
      */
    tags: z.array(z.string()).nullable().optional(),
     /**
      * dataType: int4
      * defaultValue: 0
      */
    accessCount: z.number().int().nullable().optional(),
});

/**
 * The base record type for the "public.files" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type FileInsertBaseRecord = z.output<typeof FilesTableInsertBaseSchema>;

/**
 * The base record type for the "public.files" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type FileUpdateBaseRecord = Partial<FileInsertBaseRecord>;

/**
 * Insert transform for the "public.files" table.
 * Maps app cased properties to database fields.
 */
export const transformFileInsertBaseRecord = (data: FileInsertBaseRecord): {
    id?: FileInsertBaseRecord['id'],
    filename: FileInsertBaseRecord['filename'],
    file_path: FileInsertBaseRecord['filePath'],
    file_size: FileInsertBaseRecord['fileSize'],
    mime_type?: FileInsertBaseRecord['mimeType'],
    checksum?: FileInsertBaseRecord['checksum'],
    binary_data?: FileInsertBaseRecord['binaryData'],
    is_encrypted?: FileInsertBaseRecord['isEncrypted'],
    upload_time?: FileInsertBaseRecord['uploadTime'],
    expiry_date?: FileInsertBaseRecord['expiryDate'],
    metadata?: FileInsertBaseRecord['metadata'],
    tags?: FileInsertBaseRecord['tags'],
    access_count?: FileInsertBaseRecord['accessCount'],
} => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: data.metadata,
    tags: data.tags,
    access_count: data.accessCount,
});

/**
 * Update transform for the "public.files" table.
 * Maps app cased properties to database fields.
 */
export const transformFileUpdateBaseRecord = (data: FileUpdateBaseRecord): {
    id?: FileUpdateBaseRecord['id'],
    filename: FileUpdateBaseRecord['filename'],
    file_path: FileUpdateBaseRecord['filePath'],
    file_size: FileUpdateBaseRecord['fileSize'],
    mime_type?: FileUpdateBaseRecord['mimeType'],
    checksum?: FileUpdateBaseRecord['checksum'],
    binary_data?: FileUpdateBaseRecord['binaryData'],
    is_encrypted?: FileUpdateBaseRecord['isEncrypted'],
    upload_time?: FileUpdateBaseRecord['uploadTime'],
    expiry_date?: FileUpdateBaseRecord['expiryDate'],
    metadata?: FileUpdateBaseRecord['metadata'],
    tags?: FileUpdateBaseRecord['tags'],
    access_count?: FileUpdateBaseRecord['accessCount'],
} => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: data.metadata,
    tags: data.tags,
    access_count: data.accessCount,
});

/**
 * Insert schema for the "public.files" table (after casing transform).
 */
export const FilesTableInsertSchema = FilesTableInsertBaseSchema.transform(transformFileInsertBaseRecord);

/**
 * Update schema for the "public.files" table (after casing transform).
 */
export const FilesTableUpdateSchema = FilesTableInsertBaseSchema.partial().transform(transformFileUpdateBaseRecord);

type TableInsertRecord = z.input<typeof FilesTableInsertSchema>;
type TableReadRecord = z.output<typeof FilesTableSchema>;

/**
 * Read record (casing transformed) for the "public.files" table.
 */
export interface FileRecord {
    /**
    * Primary key for files table
    */
    id: TableReadRecord['id'];
    /**
    * Original filename
    */
    filename: TableReadRecord['filename'];
    /**
    * Path to the file
    */
    filePath: TableReadRecord['filePath'];
    /**
    * Size of the file in bytes
    */
    fileSize: TableReadRecord['fileSize'];
    /**
    * MIME type of the file
    */
    mimeType?: TableReadRecord['mimeType'];
    /**
    * SHA-256 checksum of the file
    */
    checksum?: TableReadRecord['checksum'];
    /**
    * Binary data of the file
    */
    binaryData?: TableReadRecord['binaryData'];
    /**
    * Whether the file is encrypted
    */
    isEncrypted?: TableReadRecord['isEncrypted'];
    /**
    * Timestamp when file was uploaded
    */
    uploadTime?: TableReadRecord['uploadTime'];
    /**
    * Expiry date of the file
    */
    expiryDate?: TableReadRecord['expiryDate'];
    /**
    * File metadata in JSON format
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Array of file tags
    */
    tags?: TableReadRecord['tags'];
    /**
    * Number of times file was accessed
    */
    accessCount?: TableReadRecord['accessCount'];
}

/**
 * Insert record (casing transformed) for the "public.files" table.
 */
export interface FileInsertRecord {
    /**
    * Primary key for files table
    * @default: gen_random_uuid()
    */
    id?: TableInsertRecord['id'];
    /**
    * Original filename
    * @maxLen: 255
    */
    filename: TableInsertRecord['filename'];
    /**
    * Path to the file
    */
    filePath: TableInsertRecord['filePath'];
    /**
    * Size of the file in bytes
    */
    fileSize: TableInsertRecord['fileSize'];
    /**
    * MIME type of the file
    * @maxLen: 100
    */
    mimeType?: TableInsertRecord['mimeType'];
    /**
    * SHA-256 checksum of the file
    * @maxLen: 64
    */
    checksum?: TableInsertRecord['checksum'];
    /**
    * Binary data of the file
    */
    binaryData?: TableInsertRecord['binaryData'];
    /**
    * Whether the file is encrypted
    * @default: false
    */
    isEncrypted?: TableInsertRecord['isEncrypted'];
    /**
    * Timestamp when file was uploaded
    * @default: now()
    */
    uploadTime?: TableInsertRecord['uploadTime'];
    /**
    * Expiry date of the file
    */
    expiryDate?: TableInsertRecord['expiryDate'];
    /**
    * File metadata in JSON format
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Array of file tags
    */
    tags?: TableInsertRecord['tags'];
    /**
    * Number of times file was accessed
    * @default: 0
    */
    accessCount?: TableInsertRecord['accessCount'];
}

/**
 * Updatable record (casing transformed) for the "public.files" table.
 */
export type FileUpdateRecord = Partial<FileInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/geographic_data/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/geographic_data/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.geographic_data" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const GeographicDataTableBaseSchema = z.object({
     /**
      * dataType: int4
      * defaultValue: nextval('geographic_data_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: varchar
      */
    location_name: z.string(),
     /**
      * dataType: point
      */
    coordinates: z.string(),
     /**
      * dataType: polygon
      */
    boundary: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: circle
      */
    area_circle: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: float4
      */
    elevation: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    timezone: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bpchar
      */
    country_code: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: _text
      */
    postal_codes: z.array(z.string()).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      */
    population: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: date
      */
    established_date: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    last_updated: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.geographic_data" table.
 * This type represents the raw database record without case transforms.
 */
export type GeographicDataBaseRecord = z.output<typeof GeographicDataTableBaseSchema>;

/**
 * Read transform for the "public.geographic_data" table.
 * Maps database fields to app case properties.
 */
export const transformGeographicDataBaseRecord = (data: GeographicDataBaseRecord): {
    id: GeographicDataBaseRecord['id'],
    locationName: GeographicDataBaseRecord['location_name'],
    coordinates: GeographicDataBaseRecord['coordinates'],
    boundary?: GeographicDataBaseRecord['boundary'],
    areaCircle?: GeographicDataBaseRecord['area_circle'],
    elevation?: GeographicDataBaseRecord['elevation'],
    timezone?: GeographicDataBaseRecord['timezone'],
    countryCode?: GeographicDataBaseRecord['country_code'],
    postalCodes?: GeographicDataBaseRecord['postal_codes'],
    population?: GeographicDataBaseRecord['population'],
    establishedDate?: GeographicDataBaseRecord['established_date'],
    lastUpdated?: GeographicDataBaseRecord['last_updated'],
} => ({
    id: data.id,
    locationName: data.location_name,
    coordinates: data.coordinates,
    boundary: data.boundary,
    areaCircle: data.area_circle,
    elevation: data.elevation,
    timezone: data.timezone,
    countryCode: data.country_code,
    postalCodes: data.postal_codes,
    population: data.population,
    establishedDate: data.established_date,
    lastUpdated: data.last_updated,
});

/**
 * Read schema for the "public.geographic_data" table (after casing transform).
 */
export const GeographicDataTableSchema = GeographicDataTableBaseSchema.transform(transformGeographicDataBaseRecord);

/**
 * Base insert/write schema for the "public.geographic_data" table (no casing transforms).
 */
export const GeographicDataTableInsertBaseSchema = z.object({
     /**
      * dataType: varchar
      */
    locationName: z.string().max(255),
     /**
      * dataType: point
      */
    coordinates: z.string(),
     /**
      * dataType: polygon
      */
    boundary: z.string().nullable().optional(),
     /**
      * dataType: circle
      */
    areaCircle: z.string().nullable().optional(),
     /**
      * dataType: float4
      */
    elevation: z.number().nullable().optional(),
     /**
      * dataType: varchar
      */
    timezone: z.string().max(50).nullable().optional(),
     /**
      * dataType: bpchar
      */
    countryCode: z.string().max(2).nullable().optional(),
     /**
      * dataType: _text
      */
    postalCodes: z.array(z.string()).nullable().optional(),
     /**
      * dataType: int4
      */
    population: z.number().int().nullable().optional(),
     /**
      * dataType: date
      */
    establishedDate: z.date().nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    lastUpdated: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.geographic_data" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type GeographicDataInsertBaseRecord = z.output<typeof GeographicDataTableInsertBaseSchema>;

/**
 * The base record type for the "public.geographic_data" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type GeographicDataUpdateBaseRecord = Partial<GeographicDataInsertBaseRecord>;

/**
 * Insert transform for the "public.geographic_data" table.
 * Maps app cased properties to database fields.
 */
export const transformGeographicDataInsertBaseRecord = (data: GeographicDataInsertBaseRecord): {
    location_name: GeographicDataInsertBaseRecord['locationName'],
    coordinates: GeographicDataInsertBaseRecord['coordinates'],
    boundary?: GeographicDataInsertBaseRecord['boundary'],
    area_circle?: GeographicDataInsertBaseRecord['areaCircle'],
    elevation?: GeographicDataInsertBaseRecord['elevation'],
    timezone?: GeographicDataInsertBaseRecord['timezone'],
    country_code?: GeographicDataInsertBaseRecord['countryCode'],
    postal_codes?: GeographicDataInsertBaseRecord['postalCodes'],
    population?: GeographicDataInsertBaseRecord['population'],
    established_date?: GeographicDataInsertBaseRecord['establishedDate'],
    last_updated?: GeographicDataInsertBaseRecord['lastUpdated'],
} => ({
    location_name: data.locationName,
    coordinates: data.coordinates,
    boundary: data.boundary,
    area_circle: data.areaCircle,
    elevation: data.elevation,
    timezone: data.timezone,
    country_code: data.countryCode,
    postal_codes: data.postalCodes,
    population: data.population,
    established_date: data.establishedDate,
    last_updated: data.lastUpdated,
});

/**
 * Update transform for the "public.geographic_data" table.
 * Maps app cased properties to database fields.
 */
export const transformGeographicDataUpdateBaseRecord = (data: GeographicDataUpdateBaseRecord): {
    location_name: GeographicDataUpdateBaseRecord['locationName'],
    coordinates: GeographicDataUpdateBaseRecord['coordinates'],
    boundary?: GeographicDataUpdateBaseRecord['boundary'],
    area_circle?: GeographicDataUpdateBaseRecord['areaCircle'],
    elevation?: GeographicDataUpdateBaseRecord['elevation'],
    timezone?: GeographicDataUpdateBaseRecord['timezone'],
    country_code?: GeographicDataUpdateBaseRecord['countryCode'],
    postal_codes?: GeographicDataUpdateBaseRecord['postalCodes'],
    population?: GeographicDataUpdateBaseRecord['population'],
    established_date?: GeographicDataUpdateBaseRecord['establishedDate'],
    last_updated?: GeographicDataUpdateBaseRecord['lastUpdated'],
} => ({
    location_name: data.locationName,
    coordinates: data.coordinates,
    boundary: data.boundary,
    area_circle: data.areaCircle,
    elevation: data.elevation,
    timezone: data.timezone,
    country_code: data.countryCode,
    postal_codes: data.postalCodes,
    population: data.population,
    established_date: data.establishedDate,
    last_updated: data.lastUpdated,
});

/**
 * Insert schema for the "public.geographic_data" table (after casing transform).
 */
export const GeographicDataTableInsertSchema = GeographicDataTableInsertBaseSchema.transform(transformGeographicDataInsertBaseRecord);

/**
 * Update schema for the "public.geographic_data" table (after casing transform).
 */
export const GeographicDataTableUpdateSchema = GeographicDataTableInsertBaseSchema.partial().transform(transformGeographicDataUpdateBaseRecord);

type TableInsertRecord = z.input<typeof GeographicDataTableInsertSchema>;
type TableReadRecord = z.output<typeof GeographicDataTableSchema>;

/**
 * Read record (casing transformed) for the "public.geographic_data" table.
 */
export interface GeographicDataRecord {
    /**
    * Primary key for geographic data table
    */
    id: TableReadRecord['id'];
    /**
    * Name of the location
    */
    locationName: TableReadRecord['locationName'];
    /**
    * Geographic coordinates
    */
    coordinates: TableReadRecord['coordinates'];
    /**
    * Geographic boundary as polygon
    */
    boundary?: TableReadRecord['boundary'];
    /**
    * Area represented as circle
    */
    areaCircle?: TableReadRecord['areaCircle'];
    /**
    * Elevation above sea level
    */
    elevation?: TableReadRecord['elevation'];
    /**
    * Timezone of the location
    */
    timezone?: TableReadRecord['timezone'];
    /**
    * ISO country code
    */
    countryCode?: TableReadRecord['countryCode'];
    /**
    * Array of postal codes
    */
    postalCodes?: TableReadRecord['postalCodes'];
    /**
    * Population count
    */
    population?: TableReadRecord['population'];
    /**
    * Date when location was established
    */
    establishedDate?: TableReadRecord['establishedDate'];
    /**
    * Timestamp when data was last updated
    */
    lastUpdated?: TableReadRecord['lastUpdated'];
}

/**
 * Insert record (casing transformed) for the "public.geographic_data" table.
 */
export interface GeographicDataInsertRecord {
    /**
    * Name of the location
    * @maxLen: 255
    */
    locationName: TableInsertRecord['locationName'];
    /**
    * Geographic coordinates
    */
    coordinates: TableInsertRecord['coordinates'];
    /**
    * Geographic boundary as polygon
    */
    boundary?: TableInsertRecord['boundary'];
    /**
    * Area represented as circle
    */
    areaCircle?: TableInsertRecord['areaCircle'];
    /**
    * Elevation above sea level
    */
    elevation?: TableInsertRecord['elevation'];
    /**
    * Timezone of the location
    * @maxLen: 50
    */
    timezone?: TableInsertRecord['timezone'];
    /**
    * ISO country code
    * @maxLen: 2
    */
    countryCode?: TableInsertRecord['countryCode'];
    /**
    * Array of postal codes
    */
    postalCodes?: TableInsertRecord['postalCodes'];
    /**
    * Population count
    */
    population?: TableInsertRecord['population'];
    /**
    * Date when location was established
    */
    establishedDate?: TableInsertRecord['establishedDate'];
    /**
    * Timestamp when data was last updated
    * @default: now()
    */
    lastUpdated?: TableInsertRecord['lastUpdated'];
}

/**
 * Updatable record (casing transformed) for the "public.geographic_data" table.
 */
export type GeographicDataUpdateRecord = Partial<GeographicDataInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './audit_logs/index.js';
export * from './categories/index.js';
export * from './comments/index.js';
export * from './constraint_variations/index.js';
export * from './enum_tests/index.js';
export * from './files/index.js';
export * from './geographic_data/index.js';
export * from './inventory/index.js';
export * from './network_logs/index.js';
export * from './order_items/index.js';
export * from './orders/index.js';
export * from './post_categories/index.js';
export * from './posts/index.js';
export * from './products/index.js';
export * from './time_series/index.js';
export * from './user_sessions/index.js';
export * from './users/index.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/inventory/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/inventory/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.inventory" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const InventoryTableBaseSchema = z.object({
     /**
      * dataType: int4
      */
    product_id: z.number(),
     /**
      * dataType: int4
      * defaultValue: 0
      */
    stock_quantity: z.number(),
     /**
      * dataType: int4
      * defaultValue: 0
      */
    reserved_quantity: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int2
      * defaultValue: 10
      */
    reorder_level: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: date
      */
    last_restocked: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: jsonb
      */
    supplier_info: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: _text
      */
    warehouse_locations: z.array(z.string()).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    updated_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.inventory" table.
 * This type represents the raw database record without case transforms.
 */
export type InventoryBaseRecord = z.output<typeof InventoryTableBaseSchema>;

/**
 * Read transform for the "public.inventory" table.
 * Maps database fields to app case properties.
 */
export const transformInventoryBaseRecord = (data: InventoryBaseRecord): {
    productId: InventoryBaseRecord['product_id'],
    stockQuantity: InventoryBaseRecord['stock_quantity'],
    reservedQuantity?: InventoryBaseRecord['reserved_quantity'],
    reorderLevel?: InventoryBaseRecord['reorder_level'],
    lastRestocked?: InventoryBaseRecord['last_restocked'],
    supplierInfo?: InventoryBaseRecord['supplier_info'],
    warehouseLocations?: InventoryBaseRecord['warehouse_locations'],
    updatedAt?: InventoryBaseRecord['updated_at'],
} => ({
    productId: data.product_id,
    stockQuantity: data.stock_quantity,
    reservedQuantity: data.reserved_quantity,
    reorderLevel: data.reorder_level,
    lastRestocked: data.last_restocked,
    supplierInfo: data.supplier_info,
    warehouseLocations: data.warehouse_locations,
    updatedAt: data.updated_at,
});

/**
 * Read schema for the "public.inventory" table (after casing transform).
 */
export const InventoryTableSchema = InventoryTableBaseSchema.transform(transformInventoryBaseRecord);

/**
 * Base insert/write schema for the "public.inventory" table (no casing transforms).
 */
export const InventoryTableInsertBaseSchema = z.object({
     /**
      * dataType: int4
      */
    productId: z.number().int(),
     /**
      * dataType: int4
      * defaultValue: 0
      */
    stockQuantity: z.number().int().optional(),
     /**
      * dataType: int4
      * defaultValue: 0
      */
    reservedQuantity: z.number().int().nullable().optional(),
     /**
      * dataType: int2
      * defaultValue: 10
      */
    reorderLevel: z.number().int().nullable().optional(),
     /**
      * dataType: date
      */
    lastRestocked: z.date().nullable().optional(),
     /**
      * dataType: jsonb
      */
    supplierInfo: z.any().nullable().transform((value) => value ? JSON.stringify(value) : value).optional(),
     /**
      * dataType: _text
      */
    warehouseLocations: z.array(z.string()).nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    updatedAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.inventory" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type InventoryInsertBaseRecord = z.output<typeof InventoryTableInsertBaseSchema>;

/**
 * The base record type for the "public.inventory" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type InventoryUpdateBaseRecord = Partial<InventoryInsertBaseRecord>;

/**
 * Insert transform for the "public.inventory" table.
 * Maps app cased properties to database fields.
 */
export const transformInventoryInsertBaseRecord = (data: InventoryInsertBaseRecord): {
    product_id: InventoryInsertBaseRecord['productId'],
    stock_quantity?: InventoryInsertBaseRecord['stockQuantity'],
    reserved_quantity?: InventoryInsertBaseRecord['reservedQuantity'],
    reorder_level?: InventoryInsertBaseRecord['reorderLevel'],
    last_restocked?: InventoryInsertBaseRecord['lastRestocked'],
    supplier_info?: InventoryInsertBaseRecord['supplierInfo'],
    warehouse_locations?: InventoryInsertBaseRecord['warehouseLocations'],
    updated_at?: InventoryInsertBaseRecord['updatedAt'],
} => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: data.supplierInfo,
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
});

/**
 * Update transform for the "public.inventory" table.
 * Maps app cased properties to database fields.
 */
export const transformInventoryUpdateBaseRecord = (data: InventoryUpdateBaseRecord): {
    product_id: InventoryUpdateBaseRecord['productId'],
    stock_quantity?: InventoryUpdateBaseRecord['stockQuantity'],
    reserved_quantity?: InventoryUpdateBaseRecord['reservedQuantity'],
    reorder_level?: InventoryUpdateBaseRecord['reorderLevel'],
    last_restocked?: InventoryUpdateBaseRecord['lastRestocked'],
    supplier_info?: InventoryUpdateBaseRecord['supplierInfo'],
    warehouse_locations?: InventoryUpdateBaseRecord['warehouseLocations'],
    updated_at?: InventoryUpdateBaseRecord['updatedAt'],
} => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: data.supplierInfo,
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
});

/**
 * Insert schema for the "public.inventory" table (after casing transform).
 */
export const InventoryTableInsertSchema = InventoryTableInsertBaseSchema.transform(transformInventoryInsertBaseRecord);

/**
 * Update schema for the "public.inventory" table (after casing transform).
 */
export const InventoryTableUpdateSchema = InventoryTableInsertBaseSchema.partial().transform(transformInventoryUpdateBaseRecord);

type TableInsertRecord = z.input<typeof InventoryTableInsertSchema>;
type TableReadRecord = z.output<typeof InventoryTableSchema>;

/**
 * Read record (casing transformed) for the "public.inventory" table.
 */
export interface InventoryRecord {
    /**
    * ID of the product
    */
    productId: TableReadRecord['productId'];
    /**
    * Current stock quantity
    */
    stockQuantity: TableReadRecord['stockQuantity'];
    /**
    * Quantity reserved for orders
    */
    reservedQuantity?: TableReadRecord['reservedQuantity'];
    /**
    * Minimum stock level before reorder
    */
    reorderLevel?: TableReadRecord['reorderLevel'];
    /**
    * Date when last restocked
    */
    lastRestocked?: TableReadRecord['lastRestocked'];
    /**
    * Supplier information in JSON format
    */
    supplierInfo?: TableReadRecord['supplierInfo'];
    /**
    * Array of warehouse locations
    */
    warehouseLocations?: TableReadRecord['warehouseLocations'];
    /**
    * Timestamp when inventory was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
 * Insert record (casing transformed) for the "public.inventory" table.
 */
export interface InventoryInsertRecord {
    /**
    * ID of the product
    */
    productId: TableInsertRecord['productId'];
    /**
    * Current stock quantity
    * @default: 0
    */
    stockQuantity?: TableInsertRecord['stockQuantity'];
    /**
    * Quantity reserved for orders
    * @default: 0
    */
    reservedQuantity?: TableInsertRecord['reservedQuantity'];
    /**
    * Minimum stock level before reorder
    * @default: 10
    */
    reorderLevel?: TableInsertRecord['reorderLevel'];
    /**
    * Date when last restocked
    */
    lastRestocked?: TableInsertRecord['lastRestocked'];
    /**
    * Supplier information in JSON format
    */
    supplierInfo?: TableInsertRecord['supplierInfo'];
    /**
    * Array of warehouse locations
    */
    warehouseLocations?: TableInsertRecord['warehouseLocations'];
    /**
    * Timestamp when inventory was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
 * Updatable record (casing transformed) for the "public.inventory" table.
 */
export type InventoryUpdateRecord = Partial<InventoryInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/network_logs/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/network_logs/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.network_logs" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const NetworkLogsTableBaseSchema = z.object({
     /**
      * dataType: int8
      * defaultValue: nextval('network_logs_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: inet
      */
    ip_address: z.string(),
     /**
      * dataType: int4range
      */
    port_range: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: macaddr
      */
    mac_address: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    request_time: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: interval
      */
    response_time: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int8
      * defaultValue: 0
      */
    bytes_sent: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int8
      * defaultValue: 0
      */
    bytes_received: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    protocol: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int2
      */
    status_code: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    user_agent: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: jsonb
      */
    headers: z.any().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.network_logs" table.
 * This type represents the raw database record without case transforms.
 */
export type NetworkLogBaseRecord = z.output<typeof NetworkLogsTableBaseSchema>;

/**
 * Read transform for the "public.network_logs" table.
 * Maps database fields to app case properties.
 */
export const transformNetworkLogBaseRecord = (data: NetworkLogBaseRecord): {
    id: NetworkLogBaseRecord['id'],
    ipAddress: NetworkLogBaseRecord['ip_address'],
    portRange?: NetworkLogBaseRecord['port_range'],
    macAddress?: NetworkLogBaseRecord['mac_address'],
    requestTime?: NetworkLogBaseRecord['request_time'],
    responseTime?: NetworkLogBaseRecord['response_time'],
    bytesSent?: NetworkLogBaseRecord['bytes_sent'],
    bytesReceived?: NetworkLogBaseRecord['bytes_received'],
    protocol?: NetworkLogBaseRecord['protocol'],
    statusCode?: NetworkLogBaseRecord['status_code'],
    userAgent?: NetworkLogBaseRecord['user_agent'],
    headers?: NetworkLogBaseRecord['headers'],
} => ({
    id: data.id,
    ipAddress: data.ip_address,
    portRange: data.port_range,
    macAddress: data.mac_address,
    requestTime: data.request_time,
    responseTime: data.response_time,
    bytesSent: data.bytes_sent,
    bytesReceived: data.bytes_received,
    protocol: data.protocol,
    statusCode: data.status_code,
    userAgent: data.user_agent,
    headers: data.headers,
});

/**
 * Read schema for the "public.network_logs" table (after casing transform).
 */
export const NetworkLogsTableSchema = NetworkLogsTableBaseSchema.transform(transformNetworkLogBaseRecord);

/**
 * Base insert/write schema for the "public.network_logs" table (no casing transforms).
 */
export const NetworkLogsTableInsertBaseSchema = z.object({
     /**
      * dataType: inet
      */
    ipAddress: z.string(),
     /**
      * dataType: int4range
      */
    portRange: z.any().nullable().optional(),
     /**
      * dataType: macaddr
      */
    macAddress: z.string().nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    requestTime: z.date().nullable().optional(),
     /**
      * dataType: interval
      */
    responseTime: z.any().nullable().optional(),
     /**
      * dataType: int8
      * defaultValue: 0
      */
    bytesSent: z.number().int().nullable().optional(),
     /**
      * dataType: int8
      * defaultValue: 0
      */
    bytesReceived: z.number().int().nullable().optional(),
     /**
      * dataType: varchar
      */
    protocol: z.string().max(10).nullable().optional(),
     /**
      * dataType: int2
      */
    statusCode: z.number().int().nullable().optional(),
     /**
      * dataType: text
      */
    userAgent: z.string().nullable().optional(),
     /**
      * dataType: jsonb
      */
    headers: z.any().nullable().transform((value) => value ? JSON.stringify(value) : value).optional(),
});

/**
 * The base record type for the "public.network_logs" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type NetworkLogInsertBaseRecord = z.output<typeof NetworkLogsTableInsertBaseSchema>;

/**
 * The base record type for the "public.network_logs" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type NetworkLogUpdateBaseRecord = Partial<NetworkLogInsertBaseRecord>;

/**
 * Insert transform for the "public.network_logs" table.
 * Maps app cased properties to database fields.
 */
export const transformNetworkLogInsertBaseRecord = (data: NetworkLogInsertBaseRecord): {
    ip_address: NetworkLogInsertBaseRecord['ipAddress'],
    port_range?: NetworkLogInsertBaseRecord['portRange'],
    mac_address?: NetworkLogInsertBaseRecord['macAddress'],
    request_time?: NetworkLogInsertBaseRecord['requestTime'],
    response_time?: NetworkLogInsertBaseRecord['responseTime'],
    bytes_sent?: NetworkLogInsertBaseRecord['bytesSent'],
    bytes_received?: NetworkLogInsertBaseRecord['bytesReceived'],
    protocol?: NetworkLogInsertBaseRecord['protocol'],
    status_code?: NetworkLogInsertBaseRecord['statusCode'],
    user_agent?: NetworkLogInsertBaseRecord['userAgent'],
    headers?: NetworkLogInsertBaseRecord['headers'],
} => ({
    ip_address: data.ipAddress,
    port_range: data.portRange,
    mac_address: data.macAddress,
    request_time: data.requestTime,
    response_time: data.responseTime,
    bytes_sent: data.bytesSent,
    bytes_received: data.bytesReceived,
    protocol: data.protocol,
    status_code: data.statusCode,
    user_agent: data.userAgent,
    headers: data.headers,
});

/**
 * Update transform for the "public.network_logs" table.
 * Maps app cased properties to database fields.
 */
export const transformNetworkLogUpdateBaseRecord = (data: NetworkLogUpdateBaseRecord): {
    ip_address: NetworkLogUpdateBaseRecord['ipAddress'],
    port_range?: NetworkLogUpdateBaseRecord['portRange'],
    mac_address?: NetworkLogUpdateBaseRecord['macAddress'],
    request_time?: NetworkLogUpdateBaseRecord['requestTime'],
    response_time?: NetworkLogUpdateBaseRecord['responseTime'],
    bytes_sent?: NetworkLogUpdateBaseRecord['bytesSent'],
    bytes_received?: NetworkLogUpdateBaseRecord['bytesReceived'],
    protocol?: NetworkLogUpdateBaseRecord['protocol'],
    status_code?: NetworkLogUpdateBaseRecord['statusCode'],
    user_agent?: NetworkLogUpdateBaseRecord['userAgent'],
    headers?: NetworkLogUpdateBaseRecord['headers'],
} => ({
    ip_address: data.ipAddress,
    port_range: data.portRange,
    mac_address: data.macAddress,
    request_time: data.requestTime,
    response_time: data.responseTime,
    bytes_sent: data.bytesSent,
    bytes_received: data.bytesReceived,
    protocol: data.protocol,
    status_code: data.statusCode,
    user_agent: data.userAgent,
    headers: data.headers,
});

/**
 * Insert schema for the "public.network_logs" table (after casing transform).
 */
export const NetworkLogsTableInsertSchema = NetworkLogsTableInsertBaseSchema.transform(transformNetworkLogInsertBaseRecord);

/**
 * Update schema for the "public.network_logs" table (after casing transform).
 */
export const NetworkLogsTableUpdateSchema = NetworkLogsTableInsertBaseSchema.partial().transform(transformNetworkLogUpdateBaseRecord);

type TableInsertRecord = z.input<typeof NetworkLogsTableInsertSchema>;
type TableReadRecord = z.output<typeof NetworkLogsTableSchema>;

/**
 * Read record (casing transformed) for the "public.network_logs" table.
 */
export interface NetworkLogRecord {
    /**
    * Primary key for network logs table
    */
    id: TableReadRecord['id'];
    /**
    * IP address of the request
    */
    ipAddress: TableReadRecord['ipAddress'];
    /**
    * Port range used
    */
    portRange?: TableReadRecord['portRange'];
    /**
    * MAC address of the device
    */
    macAddress?: TableReadRecord['macAddress'];
    /**
    * Timestamp of the request
    */
    requestTime?: TableReadRecord['requestTime'];
    /**
    * Response time duration
    */
    responseTime?: TableReadRecord['responseTime'];
    /**
    * Number of bytes sent
    */
    bytesSent?: TableReadRecord['bytesSent'];
    /**
    * Number of bytes received
    */
    bytesReceived?: TableReadRecord['bytesReceived'];
    /**
    * Network protocol used
    */
    protocol?: TableReadRecord['protocol'];
    /**
    * HTTP status code
    */
    statusCode?: TableReadRecord['statusCode'];
    /**
    * User agent string
    */
    userAgent?: TableReadRecord['userAgent'];
    /**
    * Request headers in JSON format
    */
    headers?: TableReadRecord['headers'];
}

/**
 * Insert record (casing transformed) for the "public.network_logs" table.
 */
export interface NetworkLogInsertRecord {
    /**
    * IP address of the request
    */
    ipAddress: TableInsertRecord['ipAddress'];
    /**
    * Port range used
    */
    portRange?: TableInsertRecord['portRange'];
    /**
    * MAC address of the device
    */
    macAddress?: TableInsertRecord['macAddress'];
    /**
    * Timestamp of the request
    * @default: now()
    */
    requestTime?: TableInsertRecord['requestTime'];
    /**
    * Response time duration
    */
    responseTime?: TableInsertRecord['responseTime'];
    /**
    * Number of bytes sent
    * @default: 0
    */
    bytesSent?: TableInsertRecord['bytesSent'];
    /**
    * Number of bytes received
    * @default: 0
    */
    bytesReceived?: TableInsertRecord['bytesReceived'];
    /**
    * Network protocol used
    * @maxLen: 10
    */
    protocol?: TableInsertRecord['protocol'];
    /**
    * HTTP status code
    */
    statusCode?: TableInsertRecord['statusCode'];
    /**
    * User agent string
    */
    userAgent?: TableInsertRecord['userAgent'];
    /**
    * Request headers in JSON format
    */
    headers?: TableInsertRecord['headers'];
}

/**
 * Updatable record (casing transformed) for the "public.network_logs" table.
 */
export type NetworkLogUpdateRecord = Partial<NetworkLogInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/order_items/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/order_items/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.order_items" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const OrderItemsTableBaseSchema = z.object({
     /**
      * dataType: int8
      * defaultValue: nextval('order_items_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: int8
      */
    order_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      */
    product_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int2
      */
    quantity: z.number(),
     /**
      * dataType: numeric
      */
    unit_price: z.number(),
     /**
      * dataType: numeric
      * defaultValue: 0
      */
    discount_percent: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: numeric
      * defaultValue: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
      */
    line_total: z.number().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.order_items" table.
 * This type represents the raw database record without case transforms.
 */
export type OrderItemBaseRecord = z.output<typeof OrderItemsTableBaseSchema>;

/**
 * Read transform for the "public.order_items" table.
 * Maps database fields to app case properties.
 */
export const transformOrderItemBaseRecord = (data: OrderItemBaseRecord): {
    id: OrderItemBaseRecord['id'],
    orderId?: OrderItemBaseRecord['order_id'],
    productId?: OrderItemBaseRecord['product_id'],
    quantity: OrderItemBaseRecord['quantity'],
    unitPrice: OrderItemBaseRecord['unit_price'],
    discountPercent?: OrderItemBaseRecord['discount_percent'],
    lineTotal?: OrderItemBaseRecord['line_total'],
} => ({
    id: data.id,
    orderId: data.order_id,
    productId: data.product_id,
    quantity: data.quantity,
    unitPrice: data.unit_price,
    discountPercent: data.discount_percent,
    lineTotal: data.line_total,
});

/**
 * Read schema for the "public.order_items" table (after casing transform).
 */
export const OrderItemsTableSchema = OrderItemsTableBaseSchema.transform(transformOrderItemBaseRecord);

/**
 * Base insert/write schema for the "public.order_items" table (no casing transforms).
 */
export const OrderItemsTableInsertBaseSchema = z.object({
     /**
      * dataType: int8
      */
    orderId: z.number().int().nullable().optional(),
     /**
      * dataType: int4
      */
    productId: z.number().int().nullable().optional(),
     /**
      * dataType: int2
      */
    quantity: z.number().int(),
     /**
      * dataType: numeric
      */
    unitPrice: z.number().max(655362),
     /**
      * dataType: numeric
      * defaultValue: 0
      */
    discountPercent: z.number().max(327682).nullable().optional(),
     /**
      * dataType: numeric
      * defaultValue: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
      */
    lineTotal: z.number().max(786434).nullable().optional(),
});

/**
 * The base record type for the "public.order_items" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type OrderItemInsertBaseRecord = z.output<typeof OrderItemsTableInsertBaseSchema>;

/**
 * The base record type for the "public.order_items" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type OrderItemUpdateBaseRecord = Partial<OrderItemInsertBaseRecord>;

/**
 * Insert transform for the "public.order_items" table.
 * Maps app cased properties to database fields.
 */
export const transformOrderItemInsertBaseRecord = (data: OrderItemInsertBaseRecord): {
    order_id?: OrderItemInsertBaseRecord['orderId'],
    product_id?: OrderItemInsertBaseRecord['productId'],
    quantity: OrderItemInsertBaseRecord['quantity'],
    unit_price: OrderItemInsertBaseRecord['unitPrice'],
    discount_percent?: OrderItemInsertBaseRecord['discountPercent'],
    line_total?: OrderItemInsertBaseRecord['lineTotal'],
} => ({
    order_id: data.orderId,
    product_id: data.productId,
    quantity: data.quantity,
    unit_price: data.unitPrice,
    discount_percent: data.discountPercent,
    line_total: data.lineTotal,
});

/**
 * Update transform for the "public.order_items" table.
 * Maps app cased properties to database fields.
 */
export const transformOrderItemUpdateBaseRecord = (data: OrderItemUpdateBaseRecord): {
    order_id?: OrderItemUpdateBaseRecord['orderId'],
    product_id?: OrderItemUpdateBaseRecord['productId'],
    quantity: OrderItemUpdateBaseRecord['quantity'],
    unit_price: OrderItemUpdateBaseRecord['unitPrice'],
    discount_percent?: OrderItemUpdateBaseRecord['discountPercent'],
    line_total?: OrderItemUpdateBaseRecord['lineTotal'],
} => ({
    order_id: data.orderId,
    product_id: data.productId,
    quantity: data.quantity,
    unit_price: data.unitPrice,
    discount_percent: data.discountPercent,
    line_total: data.lineTotal,
});

/**
 * Insert schema for the "public.order_items" table (after casing transform).
 */
export const OrderItemsTableInsertSchema = OrderItemsTableInsertBaseSchema.transform(transformOrderItemInsertBaseRecord);

/**
 * Update schema for the "public.order_items" table (after casing transform).
 */
export const OrderItemsTableUpdateSchema = OrderItemsTableInsertBaseSchema.partial().transform(transformOrderItemUpdateBaseRecord);

type TableInsertRecord = z.input<typeof OrderItemsTableInsertSchema>;
type TableReadRecord = z.output<typeof OrderItemsTableSchema>;

/**
 * Read record (casing transformed) for the "public.order_items" table.
 */
export interface OrderItemRecord {
    /**
    * Primary key for order items table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the order this item belongs to
    */
    orderId?: TableReadRecord['orderId'];
    /**
    * ID of the product
    */
    productId?: TableReadRecord['productId'];
    /**
    * Quantity of the product ordered
    */
    quantity: TableReadRecord['quantity'];
    /**
    * Price per unit
    */
    unitPrice: TableReadRecord['unitPrice'];
    /**
    * Discount percentage applied
    */
    discountPercent?: TableReadRecord['discountPercent'];
    /**
    * Calculated line total
    */
    lineTotal?: TableReadRecord['lineTotal'];
}

/**
 * Insert record (casing transformed) for the "public.order_items" table.
 */
export interface OrderItemInsertRecord {
    /**
    * ID of the order this item belongs to
    */
    orderId?: TableInsertRecord['orderId'];
    /**
    * ID of the product
    */
    productId?: TableInsertRecord['productId'];
    /**
    * Quantity of the product ordered
    */
    quantity: TableInsertRecord['quantity'];
    /**
    * Price per unit
    * @maxLen: 655362
    */
    unitPrice: TableInsertRecord['unitPrice'];
    /**
    * Discount percentage applied
    * @maxLen: 327682
    * @default: 0
    */
    discountPercent?: TableInsertRecord['discountPercent'];
    /**
    * Calculated line total
    * @maxLen: 786434
    * @default: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    lineTotal?: TableInsertRecord['lineTotal'];
}

/**
 * Updatable record (casing transformed) for the "public.order_items" table.
 */
export type OrderItemUpdateRecord = Partial<OrderItemInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/orders/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/orders/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.orders" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const OrdersTableBaseSchema = z.object({
     /**
      * dataType: int8
      * defaultValue: nextval('orders_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: varchar
      */
    order_number: z.string(),
     /**
      * dataType: int4
      */
    user_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: order_status
      * defaultValue: 'pending'::order_status
      */
    status: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: money
      */
    total_amount: z.number(),
     /**
      * dataType: money
      * defaultValue: 0
      */
    tax_amount: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: money
      * defaultValue: 0
      */
    shipping_cost: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: date
      * defaultValue: CURRENT_DATE
      */
    order_date: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: date
      */
    shipped_date: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: time
      */
    delivery_time: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: _text
      */
    notes: z.array(z.string()).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: jsonb
      */
    metadata: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.orders" table.
 * This type represents the raw database record without case transforms.
 */
export type OrderBaseRecord = z.output<typeof OrdersTableBaseSchema>;

/**
 * Read transform for the "public.orders" table.
 * Maps database fields to app case properties.
 */
export const transformOrderBaseRecord = (data: OrderBaseRecord): {
    id: OrderBaseRecord['id'],
    orderNumber: OrderBaseRecord['order_number'],
    userId?: OrderBaseRecord['user_id'],
    status?: OrderBaseRecord['status'],
    totalAmount: OrderBaseRecord['total_amount'],
    taxAmount?: OrderBaseRecord['tax_amount'],
    shippingCost?: OrderBaseRecord['shipping_cost'],
    orderDate?: OrderBaseRecord['order_date'],
    shippedDate?: OrderBaseRecord['shipped_date'],
    deliveryTime?: OrderBaseRecord['delivery_time'],
    notes?: OrderBaseRecord['notes'],
    metadata?: OrderBaseRecord['metadata'],
    createdAt?: OrderBaseRecord['created_at'],
} => ({
    id: data.id,
    orderNumber: data.order_number,
    userId: data.user_id,
    status: data.status,
    totalAmount: data.total_amount,
    taxAmount: data.tax_amount,
    shippingCost: data.shipping_cost,
    orderDate: data.order_date,
    shippedDate: data.shipped_date,
    deliveryTime: data.delivery_time,
    notes: data.notes,
    metadata: data.metadata,
    createdAt: data.created_at,
});

/**
 * Read schema for the "public.orders" table (after casing transform).
 */
export const OrdersTableSchema = OrdersTableBaseSchema.transform(transformOrderBaseRecord);

/**
 * Base insert/write schema for the "public.orders" table (no casing transforms).
 */
export const OrdersTableInsertBaseSchema = z.object({
     /**
      * dataType: varchar
      */
    orderNumber: z.string().max(20),
     /**
      * dataType: int4
      */
    userId: z.number().int().nullable().optional(),
     /**
      * dataType: order_status
      * defaultValue: 'pending'::order_status
      */
    status: z.any().nullable().optional(),
     /**
      * dataType: money
      */
    totalAmount: z.number(),
     /**
      * dataType: money
      * defaultValue: 0
      */
    taxAmount: z.number().nullable().optional(),
     /**
      * dataType: money
      * defaultValue: 0
      */
    shippingCost: z.number().nullable().optional(),
     /**
      * dataType: date
      * defaultValue: CURRENT_DATE
      */
    orderDate: z.date().nullable().optional(),
     /**
      * dataType: date
      */
    shippedDate: z.date().nullable().optional(),
     /**
      * dataType: time
      */
    deliveryTime: z.string().nullable().optional(),
     /**
      * dataType: _text
      */
    notes: z.array(z.string()).nullable().optional(),
     /**
      * dataType: jsonb
      */
    metadata: z.any().nullable().transform((value) => value ? JSON.stringify(value) : value).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.orders" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type OrderInsertBaseRecord = z.output<typeof OrdersTableInsertBaseSchema>;

/**
 * The base record type for the "public.orders" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type OrderUpdateBaseRecord = Partial<OrderInsertBaseRecord>;

/**
 * Insert transform for the "public.orders" table.
 * Maps app cased properties to database fields.
 */
export const transformOrderInsertBaseRecord = (data: OrderInsertBaseRecord): {
    order_number: OrderInsertBaseRecord['orderNumber'],
    user_id?: OrderInsertBaseRecord['userId'],
    status?: OrderInsertBaseRecord['status'],
    total_amount: OrderInsertBaseRecord['totalAmount'],
    tax_amount?: OrderInsertBaseRecord['taxAmount'],
    shipping_cost?: OrderInsertBaseRecord['shippingCost'],
    order_date?: OrderInsertBaseRecord['orderDate'],
    shipped_date?: OrderInsertBaseRecord['shippedDate'],
    delivery_time?: OrderInsertBaseRecord['deliveryTime'],
    notes?: OrderInsertBaseRecord['notes'],
    metadata?: OrderInsertBaseRecord['metadata'],
    created_at?: OrderInsertBaseRecord['createdAt'],
} => ({
    order_number: data.orderNumber,
    user_id: data.userId,
    status: data.status,
    total_amount: data.totalAmount,
    tax_amount: data.taxAmount,
    shipping_cost: data.shippingCost,
    order_date: data.orderDate,
    shipped_date: data.shippedDate,
    delivery_time: data.deliveryTime,
    notes: data.notes,
    metadata: data.metadata,
    created_at: data.createdAt,
});

/**
 * Update transform for the "public.orders" table.
 * Maps app cased properties to database fields.
 */
export const transformOrderUpdateBaseRecord = (data: OrderUpdateBaseRecord): {
    order_number: OrderUpdateBaseRecord['orderNumber'],
    user_id?: OrderUpdateBaseRecord['userId'],
    status?: OrderUpdateBaseRecord['status'],
    total_amount: OrderUpdateBaseRecord['totalAmount'],
    tax_amount?: OrderUpdateBaseRecord['taxAmount'],
    shipping_cost?: OrderUpdateBaseRecord['shippingCost'],
    order_date?: OrderUpdateBaseRecord['orderDate'],
    shipped_date?: OrderUpdateBaseRecord['shippedDate'],
    delivery_time?: OrderUpdateBaseRecord['deliveryTime'],
    notes?: OrderUpdateBaseRecord['notes'],
    metadata?: OrderUpdateBaseRecord['metadata'],
    created_at?: OrderUpdateBaseRecord['createdAt'],
} => ({
    order_number: data.orderNumber,
    user_id: data.userId,
    status: data.status,
    total_amount: data.totalAmount,
    tax_amount: data.taxAmount,
    shipping_cost: data.shippingCost,
    order_date: data.orderDate,
    shipped_date: data.shippedDate,
    delivery_time: data.deliveryTime,
    notes: data.notes,
    metadata: data.metadata,
    created_at: data.createdAt,
});

/**
 * Insert schema for the "public.orders" table (after casing transform).
 */
export const OrdersTableInsertSchema = OrdersTableInsertBaseSchema.transform(transformOrderInsertBaseRecord);

/**
 * Update schema for the "public.orders" table (after casing transform).
 */
export const OrdersTableUpdateSchema = OrdersTableInsertBaseSchema.partial().transform(transformOrderUpdateBaseRecord);

type TableInsertRecord = z.input<typeof OrdersTableInsertSchema>;
type TableReadRecord = z.output<typeof OrdersTableSchema>;

/**
 * Read record (casing transformed) for the "public.orders" table.
 */
export interface OrderRecord {
    /**
    * Primary key for orders table
    */
    id: TableReadRecord['id'];
    /**
    * Unique order number
    */
    orderNumber: TableReadRecord['orderNumber'];
    /**
    * ID of the user who placed the order
    */
    userId?: TableReadRecord['userId'];
    /**
    * Current status of the order
    */
    status?: TableReadRecord['status'];
    /**
    * Total order amount
    */
    totalAmount: TableReadRecord['totalAmount'];
    /**
    * Tax amount for the order
    */
    taxAmount?: TableReadRecord['taxAmount'];
    /**
    * Shipping cost for the order
    */
    shippingCost?: TableReadRecord['shippingCost'];
    /**
    * Date when order was placed
    */
    orderDate?: TableReadRecord['orderDate'];
    /**
    * Date when order was shipped
    */
    shippedDate?: TableReadRecord['shippedDate'];
    /**
    * Expected delivery time
    */
    deliveryTime?: TableReadRecord['deliveryTime'];
    /**
    * Array of order notes
    */
    notes?: TableReadRecord['notes'];
    /**
    * Additional order metadata
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Timestamp when order was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
 * Insert record (casing transformed) for the "public.orders" table.
 */
export interface OrderInsertRecord {
    /**
    * Unique order number
    * @maxLen: 20
    */
    orderNumber: TableInsertRecord['orderNumber'];
    /**
    * ID of the user who placed the order
    */
    userId?: TableInsertRecord['userId'];
    /**
    * Current status of the order
    * @default: 'pending'::order_status
    */
    status?: TableInsertRecord['status'];
    /**
    * Total order amount
    */
    totalAmount: TableInsertRecord['totalAmount'];
    /**
    * Tax amount for the order
    * @default: 0
    */
    taxAmount?: TableInsertRecord['taxAmount'];
    /**
    * Shipping cost for the order
    * @default: 0
    */
    shippingCost?: TableInsertRecord['shippingCost'];
    /**
    * Date when order was placed
    * @default: CURRENT_DATE
    */
    orderDate?: TableInsertRecord['orderDate'];
    /**
    * Date when order was shipped
    */
    shippedDate?: TableInsertRecord['shippedDate'];
    /**
    * Expected delivery time
    */
    deliveryTime?: TableInsertRecord['deliveryTime'];
    /**
    * Array of order notes
    */
    notes?: TableInsertRecord['notes'];
    /**
    * Additional order metadata
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Timestamp when order was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
 * Updatable record (casing transformed) for the "public.orders" table.
 */
export type OrderUpdateRecord = Partial<OrderInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/post_categories/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/post_categories/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.post_categories" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const PostCategoriesTableBaseSchema = z.object({
     /**
      * dataType: int4
      */
    post_id: z.number(),
     /**
      * dataType: int4
      */
    category_id: z.number(),
});

/**
 * The base record type for the "public.post_categories" table.
 * This type represents the raw database record without case transforms.
 */
export type PostCategoryBaseRecord = z.output<typeof PostCategoriesTableBaseSchema>;

/**
 * Read transform for the "public.post_categories" table.
 * Maps database fields to app case properties.
 */
export const transformPostCategoryBaseRecord = (data: PostCategoryBaseRecord): {
    postId: PostCategoryBaseRecord['post_id'],
    categoryId: PostCategoryBaseRecord['category_id'],
} => ({
    postId: data.post_id,
    categoryId: data.category_id,
});

/**
 * Read schema for the "public.post_categories" table (after casing transform).
 */
export const PostCategoriesTableSchema = PostCategoriesTableBaseSchema.transform(transformPostCategoryBaseRecord);

/**
 * Base insert/write schema for the "public.post_categories" table (no casing transforms).
 */
export const PostCategoriesTableInsertBaseSchema = z.object({
     /**
      * dataType: int4
      */
    postId: z.number().int(),
     /**
      * dataType: int4
      */
    categoryId: z.number().int(),
});

/**
 * The base record type for the "public.post_categories" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type PostCategoryInsertBaseRecord = z.output<typeof PostCategoriesTableInsertBaseSchema>;

/**
 * The base record type for the "public.post_categories" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type PostCategoryUpdateBaseRecord = Partial<PostCategoryInsertBaseRecord>;

/**
 * Insert transform for the "public.post_categories" table.
 * Maps app cased properties to database fields.
 */
export const transformPostCategoryInsertBaseRecord = (data: PostCategoryInsertBaseRecord): {
    post_id: PostCategoryInsertBaseRecord['postId'],
    category_id: PostCategoryInsertBaseRecord['categoryId'],
} => ({
    post_id: data.postId,
    category_id: data.categoryId,
});

/**
 * Update transform for the "public.post_categories" table.
 * Maps app cased properties to database fields.
 */
export const transformPostCategoryUpdateBaseRecord = (data: PostCategoryUpdateBaseRecord): {
    post_id: PostCategoryUpdateBaseRecord['postId'],
    category_id: PostCategoryUpdateBaseRecord['categoryId'],
} => ({
    post_id: data.postId,
    category_id: data.categoryId,
});

/**
 * Insert schema for the "public.post_categories" table (after casing transform).
 */
export const PostCategoriesTableInsertSchema = PostCategoriesTableInsertBaseSchema.transform(transformPostCategoryInsertBaseRecord);

/**
 * Update schema for the "public.post_categories" table (after casing transform).
 */
export const PostCategoriesTableUpdateSchema = PostCategoriesTableInsertBaseSchema.partial().transform(transformPostCategoryUpdateBaseRecord);

type TableInsertRecord = z.input<typeof PostCategoriesTableInsertSchema>;
type TableReadRecord = z.output<typeof PostCategoriesTableSchema>;

/**
 * Read record (casing transformed) for the "public.post_categories" table.
 */
export interface PostCategoryRecord {
    /**
    * ID of the post
    */
    postId: TableReadRecord['postId'];
    /**
    * ID of the category
    */
    categoryId: TableReadRecord['categoryId'];
}

/**
 * Insert record (casing transformed) for the "public.post_categories" table.
 */
export interface PostCategoryInsertRecord {
    /**
    * ID of the post
    */
    postId: TableInsertRecord['postId'];
    /**
    * ID of the category
    */
    categoryId: TableInsertRecord['categoryId'];
}

/**
 * Updatable record (casing transformed) for the "public.post_categories" table.
 */
export type PostCategoryUpdateRecord = Partial<PostCategoryInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/posts/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/posts/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';

export const POST_STATUSES = ['draft', 'published', 'archived'] as const;

/**
 * Base read schema for the "public.posts" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const PostsTableBaseSchema = z.object({
     /**
      * dataType: int4
      * defaultValue: nextval('posts_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: int4
      */
    user_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    title: z.string(),
     /**
      * dataType: text
      */
    content: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bool
      * defaultValue: false
      */
    published: z.boolean().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      * defaultValue: 'draft'::character varying
      */
    status: z.enum(POST_STATUSES).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      * defaultValue: 0
      */
    views: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: _text
      */
    tags: z.array(z.string()).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: jsonb
      */
    metadata: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      */
    published_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    updated_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents the raw database record without case transforms.
 */
export type PostBaseRecord = z.output<typeof PostsTableBaseSchema>;

/**
 * Read transform for the "public.posts" table.
 * Maps database fields to app case properties.
 */
export const transformPostBaseRecord = (data: PostBaseRecord): {
    id: PostBaseRecord['id'],
    userId?: PostBaseRecord['user_id'],
    title: PostBaseRecord['title'],
    content?: PostBaseRecord['content'],
    published?: PostBaseRecord['published'],
    status?: PostBaseRecord['status'],
    views?: PostBaseRecord['views'],
    tags?: PostBaseRecord['tags'],
    metadata?: PostBaseRecord['metadata'],
    publishedAt?: PostBaseRecord['published_at'],
    updatedAt?: PostBaseRecord['updated_at'],
} => ({
    id: data.id,
    userId: data.user_id,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    publishedAt: data.published_at,
    updatedAt: data.updated_at,
});

/**
 * Read schema for the "public.posts" table (after casing transform).
 */
export const PostsTableSchema = PostsTableBaseSchema.transform(transformPostBaseRecord);

/**
 * Base insert/write schema for the "public.posts" table (no casing transforms).
 */
export const PostsTableInsertBaseSchema = z.object({
     /**
      * dataType: int4
      */
    userId: z.number().int().nullable().optional(),
     /**
      * dataType: text
      */
    title: z.string(),
     /**
      * dataType: text
      */
    content: z.string().nullable().optional(),
     /**
      * dataType: bool
      * defaultValue: false
      */
    published: z.boolean().nullable().optional(),
     /**
      * dataType: varchar
      * defaultValue: 'draft'::character varying
      */
    status: z.enum(POST_STATUSES).nullable().optional(),
     /**
      * dataType: int4
      * defaultValue: 0
      */
    views: z.number().int().nullable().optional(),
     /**
      * dataType: _text
      */
    tags: z.array(z.string()).nullable().optional(),
     /**
      * dataType: jsonb
      */
    metadata: z.any().nullable().transform((value) => value ? JSON.stringify(value) : value).optional(),
     /**
      * dataType: timestamptz
      */
    publishedAt: z.date().nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    updatedAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type PostInsertBaseRecord = z.output<typeof PostsTableInsertBaseSchema>;

/**
 * The base record type for the "public.posts" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type PostUpdateBaseRecord = Partial<PostInsertBaseRecord>;

/**
 * Insert transform for the "public.posts" table.
 * Maps app cased properties to database fields.
 */
export const transformPostInsertBaseRecord = (data: PostInsertBaseRecord): {
    user_id?: PostInsertBaseRecord['userId'],
    title: PostInsertBaseRecord['title'],
    content?: PostInsertBaseRecord['content'],
    published?: PostInsertBaseRecord['published'],
    status?: PostInsertBaseRecord['status'],
    views?: PostInsertBaseRecord['views'],
    tags?: PostInsertBaseRecord['tags'],
    metadata?: PostInsertBaseRecord['metadata'],
    published_at?: PostInsertBaseRecord['publishedAt'],
    updated_at?: PostInsertBaseRecord['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * Update transform for the "public.posts" table.
 * Maps app cased properties to database fields.
 */
export const transformPostUpdateBaseRecord = (data: PostUpdateBaseRecord): {
    user_id?: PostUpdateBaseRecord['userId'],
    title: PostUpdateBaseRecord['title'],
    content?: PostUpdateBaseRecord['content'],
    published?: PostUpdateBaseRecord['published'],
    status?: PostUpdateBaseRecord['status'],
    views?: PostUpdateBaseRecord['views'],
    tags?: PostUpdateBaseRecord['tags'],
    metadata?: PostUpdateBaseRecord['metadata'],
    published_at?: PostUpdateBaseRecord['publishedAt'],
    updated_at?: PostUpdateBaseRecord['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * Insert schema for the "public.posts" table (after casing transform).
 */
export const PostsTableInsertSchema = PostsTableInsertBaseSchema.transform(transformPostInsertBaseRecord);

/**
 * Update schema for the "public.posts" table (after casing transform).
 */
export const PostsTableUpdateSchema = PostsTableInsertBaseSchema.partial().transform(transformPostUpdateBaseRecord);

type TableInsertRecord = z.input<typeof PostsTableInsertSchema>;
type TableReadRecord = z.output<typeof PostsTableSchema>;

/**
 * Read record (casing transformed) for the "public.posts" table.
 */
export interface PostRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    title: TableReadRecord['title'];
    /**
    */
    content?: TableReadRecord['content'];
    /**
    */
    published?: TableReadRecord['published'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    * Number of views for the post
    */
    views?: TableReadRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableReadRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableReadRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
 * Insert record (casing transformed) for the "public.posts" table.
 */
export interface PostInsertRecord {
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    */
    title: TableInsertRecord['title'];
    /**
    */
    content?: TableInsertRecord['content'];
    /**
    * @default: false
    */
    published?: TableInsertRecord['published'];
    /**
    * @maxLen: 20
    * @default: 'draft'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    * Number of views for the post
    * @default: 0
    */
    views?: TableInsertRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableInsertRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableInsertRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
 * Updatable record (casing transformed) for the "public.posts" table.
 */
export type PostUpdateRecord = Partial<PostInsertRecord>;

export type PostStatus = (typeof POST_STATUSES)[number];
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/products/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/products/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.products" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const ProductsTableBaseSchema = z.object({
     /**
      * dataType: int4
      * defaultValue: nextval('products_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: varchar
      */
    name: z.string(),
     /**
      * dataType: varchar
      */
    sku: z.string(),
     /**
      * dataType: numeric
      */
    price: z.number(),
     /**
      * dataType: numeric
      */
    cost: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: float4
      */
    weight: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: point
      */
    dimensions: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bool
      * defaultValue: true
      */
    is_active: z.boolean().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bpchar
      */
    barcode: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    description: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.products" table.
 * This type represents the raw database record without case transforms.
 */
export type ProductBaseRecord = z.output<typeof ProductsTableBaseSchema>;

/**
 * Read transform for the "public.products" table.
 * Maps database fields to app case properties.
 */
export const transformProductBaseRecord = (data: ProductBaseRecord): {
    id: ProductBaseRecord['id'],
    name: ProductBaseRecord['name'],
    sku: ProductBaseRecord['sku'],
    price: ProductBaseRecord['price'],
    cost?: ProductBaseRecord['cost'],
    weight?: ProductBaseRecord['weight'],
    dimensions?: ProductBaseRecord['dimensions'],
    isActive?: ProductBaseRecord['is_active'],
    barcode?: ProductBaseRecord['barcode'],
    description?: ProductBaseRecord['description'],
    createdAt?: ProductBaseRecord['created_at'],
} => ({
    id: data.id,
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    isActive: data.is_active,
    barcode: data.barcode,
    description: data.description,
    createdAt: data.created_at,
});

/**
 * Read schema for the "public.products" table (after casing transform).
 */
export const ProductsTableSchema = ProductsTableBaseSchema.transform(transformProductBaseRecord);

/**
 * Base insert/write schema for the "public.products" table (no casing transforms).
 */
export const ProductsTableInsertBaseSchema = z.object({
     /**
      * dataType: varchar
      */
    name: z.string().max(255),
     /**
      * dataType: varchar
      */
    sku: z.string().max(50),
     /**
      * dataType: numeric
      */
    price: z.number().max(655362),
     /**
      * dataType: numeric
      */
    cost: z.number().max(655362).nullable().optional(),
     /**
      * dataType: float4
      */
    weight: z.number().nullable().optional(),
     /**
      * dataType: point
      */
    dimensions: z.string().nullable().optional(),
     /**
      * dataType: bool
      * defaultValue: true
      */
    isActive: z.boolean().nullable().optional(),
     /**
      * dataType: bpchar
      */
    barcode: z.string().max(13).nullable().optional(),
     /**
      * dataType: text
      */
    description: z.string().nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.products" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type ProductInsertBaseRecord = z.output<typeof ProductsTableInsertBaseSchema>;

/**
 * The base record type for the "public.products" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type ProductUpdateBaseRecord = Partial<ProductInsertBaseRecord>;

/**
 * Insert transform for the "public.products" table.
 * Maps app cased properties to database fields.
 */
export const transformProductInsertBaseRecord = (data: ProductInsertBaseRecord): {
    name: ProductInsertBaseRecord['name'],
    sku: ProductInsertBaseRecord['sku'],
    price: ProductInsertBaseRecord['price'],
    cost?: ProductInsertBaseRecord['cost'],
    weight?: ProductInsertBaseRecord['weight'],
    dimensions?: ProductInsertBaseRecord['dimensions'],
    is_active?: ProductInsertBaseRecord['isActive'],
    barcode?: ProductInsertBaseRecord['barcode'],
    description?: ProductInsertBaseRecord['description'],
    created_at?: ProductInsertBaseRecord['createdAt'],
} => ({
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    is_active: data.isActive,
    barcode: data.barcode,
    description: data.description,
    created_at: data.createdAt,
});

/**
 * Update transform for the "public.products" table.
 * Maps app cased properties to database fields.
 */
export const transformProductUpdateBaseRecord = (data: ProductUpdateBaseRecord): {
    name: ProductUpdateBaseRecord['name'],
    sku: ProductUpdateBaseRecord['sku'],
    price: ProductUpdateBaseRecord['price'],
    cost?: ProductUpdateBaseRecord['cost'],
    weight?: ProductUpdateBaseRecord['weight'],
    dimensions?: ProductUpdateBaseRecord['dimensions'],
    is_active?: ProductUpdateBaseRecord['isActive'],
    barcode?: ProductUpdateBaseRecord['barcode'],
    description?: ProductUpdateBaseRecord['description'],
    created_at?: ProductUpdateBaseRecord['createdAt'],
} => ({
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    is_active: data.isActive,
    barcode: data.barcode,
    description: data.description,
    created_at: data.createdAt,
});

/**
 * Insert schema for the "public.products" table (after casing transform).
 */
export const ProductsTableInsertSchema = ProductsTableInsertBaseSchema.transform(transformProductInsertBaseRecord);

/**
 * Update schema for the "public.products" table (after casing transform).
 */
export const ProductsTableUpdateSchema = ProductsTableInsertBaseSchema.partial().transform(transformProductUpdateBaseRecord);

type TableInsertRecord = z.input<typeof ProductsTableInsertSchema>;
type TableReadRecord = z.output<typeof ProductsTableSchema>;

/**
 * Read record (casing transformed) for the "public.products" table.
 */
export interface ProductRecord {
    /**
    * Primary key for products table
    */
    id: TableReadRecord['id'];
    /**
    * Product name
    */
    name: TableReadRecord['name'];
    /**
    * Stock keeping unit identifier
    */
    sku: TableReadRecord['sku'];
    /**
    * Product price with 2 decimal precision
    */
    price: TableReadRecord['price'];
    /**
    * Product cost with 2 decimal precision
    */
    cost?: TableReadRecord['cost'];
    /**
    * Product weight in kilograms
    */
    weight?: TableReadRecord['weight'];
    /**
    * Product dimensions as geometric point
    */
    dimensions?: TableReadRecord['dimensions'];
    /**
    * Whether the product is active
    */
    isActive?: TableReadRecord['isActive'];
    /**
    * Product barcode (13 characters)
    */
    barcode?: TableReadRecord['barcode'];
    /**
    * Product description
    */
    description?: TableReadRecord['description'];
    /**
    * Timestamp when product was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
 * Insert record (casing transformed) for the "public.products" table.
 */
export interface ProductInsertRecord {
    /**
    * Product name
    * @maxLen: 255
    */
    name: TableInsertRecord['name'];
    /**
    * Stock keeping unit identifier
    * @maxLen: 50
    */
    sku: TableInsertRecord['sku'];
    /**
    * Product price with 2 decimal precision
    * @maxLen: 655362
    */
    price: TableInsertRecord['price'];
    /**
    * Product cost with 2 decimal precision
    * @maxLen: 655362
    */
    cost?: TableInsertRecord['cost'];
    /**
    * Product weight in kilograms
    */
    weight?: TableInsertRecord['weight'];
    /**
    * Product dimensions as geometric point
    */
    dimensions?: TableInsertRecord['dimensions'];
    /**
    * Whether the product is active
    * @default: true
    */
    isActive?: TableInsertRecord['isActive'];
    /**
    * Product barcode (13 characters)
    * @maxLen: 13
    */
    barcode?: TableInsertRecord['barcode'];
    /**
    * Product description
    */
    description?: TableInsertRecord['description'];
    /**
    * Timestamp when product was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
 * Updatable record (casing transformed) for the "public.products" table.
 */
export type ProductUpdateRecord = Partial<ProductInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/time_series/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/time_series/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.time_series" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const TimeSeriesTableBaseSchema = z.object({
     /**
      * dataType: int8
      * defaultValue: nextval('time_series_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: varchar
      */
    sensor_id: z.string(),
     /**
      * dataType: timestamptz
      */
    timestamp: z.coerce.date(),
     /**
      * dataType: numeric
      */
    temperature: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: numeric
      */
    humidity: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: numeric
      */
    pressure: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: _numeric
      */
    readings: z.array(z.number()).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: bool
      * defaultValue: false
      */
    anomaly_detected: z.boolean().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int2
      */
    data_quality: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.time_series" table.
 * This type represents the raw database record without case transforms.
 */
export type TimeSeriesBaseRecord = z.output<typeof TimeSeriesTableBaseSchema>;

/**
 * Read transform for the "public.time_series" table.
 * Maps database fields to app case properties.
 */
export const transformTimeSeriesBaseRecord = (data: TimeSeriesBaseRecord): {
    id: TimeSeriesBaseRecord['id'],
    sensorId: TimeSeriesBaseRecord['sensor_id'],
    timestamp: TimeSeriesBaseRecord['timestamp'],
    temperature?: TimeSeriesBaseRecord['temperature'],
    humidity?: TimeSeriesBaseRecord['humidity'],
    pressure?: TimeSeriesBaseRecord['pressure'],
    readings?: TimeSeriesBaseRecord['readings'],
    anomalyDetected?: TimeSeriesBaseRecord['anomaly_detected'],
    dataQuality?: TimeSeriesBaseRecord['data_quality'],
    createdAt?: TimeSeriesBaseRecord['created_at'],
} => ({
    id: data.id,
    sensorId: data.sensor_id,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomalyDetected: data.anomaly_detected,
    dataQuality: data.data_quality,
    createdAt: data.created_at,
});

/**
 * Read schema for the "public.time_series" table (after casing transform).
 */
export const TimeSeriesTableSchema = TimeSeriesTableBaseSchema.transform(transformTimeSeriesBaseRecord);

/**
 * Base insert/write schema for the "public.time_series" table (no casing transforms).
 */
export const TimeSeriesTableInsertBaseSchema = z.object({
     /**
      * dataType: varchar
      */
    sensorId: z.string().max(50),
     /**
      * dataType: timestamptz
      */
    timestamp: z.date(),
     /**
      * dataType: numeric
      */
    temperature: z.number().max(327682).nullable().optional(),
     /**
      * dataType: numeric
      */
    humidity: z.number().max(327682).nullable().optional(),
     /**
      * dataType: numeric
      */
    pressure: z.number().max(458754).nullable().optional(),
     /**
      * dataType: _numeric
      */
    readings: z.array(z.number()).nullable().optional(),
     /**
      * dataType: bool
      * defaultValue: false
      */
    anomalyDetected: z.boolean().nullable().optional(),
     /**
      * dataType: int2
      */
    dataQuality: z.number().int().nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.time_series" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type TimeSeriesInsertBaseRecord = z.output<typeof TimeSeriesTableInsertBaseSchema>;

/**
 * The base record type for the "public.time_series" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type TimeSeriesUpdateBaseRecord = Partial<TimeSeriesInsertBaseRecord>;

/**
 * Insert transform for the "public.time_series" table.
 * Maps app cased properties to database fields.
 */
export const transformTimeSeriesInsertBaseRecord = (data: TimeSeriesInsertBaseRecord): {
    sensor_id: TimeSeriesInsertBaseRecord['sensorId'],
    timestamp: TimeSeriesInsertBaseRecord['timestamp'],
    temperature?: TimeSeriesInsertBaseRecord['temperature'],
    humidity?: TimeSeriesInsertBaseRecord['humidity'],
    pressure?: TimeSeriesInsertBaseRecord['pressure'],
    readings?: TimeSeriesInsertBaseRecord['readings'],
    anomaly_detected?: TimeSeriesInsertBaseRecord['anomalyDetected'],
    data_quality?: TimeSeriesInsertBaseRecord['dataQuality'],
    created_at?: TimeSeriesInsertBaseRecord['createdAt'],
} => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
});

/**
 * Update transform for the "public.time_series" table.
 * Maps app cased properties to database fields.
 */
export const transformTimeSeriesUpdateBaseRecord = (data: TimeSeriesUpdateBaseRecord): {
    sensor_id: TimeSeriesUpdateBaseRecord['sensorId'],
    timestamp: TimeSeriesUpdateBaseRecord['timestamp'],
    temperature?: TimeSeriesUpdateBaseRecord['temperature'],
    humidity?: TimeSeriesUpdateBaseRecord['humidity'],
    pressure?: TimeSeriesUpdateBaseRecord['pressure'],
    readings?: TimeSeriesUpdateBaseRecord['readings'],
    anomaly_detected?: TimeSeriesUpdateBaseRecord['anomalyDetected'],
    data_quality?: TimeSeriesUpdateBaseRecord['dataQuality'],
    created_at?: TimeSeriesUpdateBaseRecord['createdAt'],
} => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
});

/**
 * Insert schema for the "public.time_series" table (after casing transform).
 */
export const TimeSeriesTableInsertSchema = TimeSeriesTableInsertBaseSchema.transform(transformTimeSeriesInsertBaseRecord);

/**
 * Update schema for the "public.time_series" table (after casing transform).
 */
export const TimeSeriesTableUpdateSchema = TimeSeriesTableInsertBaseSchema.partial().transform(transformTimeSeriesUpdateBaseRecord);

type TableInsertRecord = z.input<typeof TimeSeriesTableInsertSchema>;
type TableReadRecord = z.output<typeof TimeSeriesTableSchema>;

/**
 * Read record (casing transformed) for the "public.time_series" table.
 */
export interface TimeSeriesRecord {
    /**
    * Primary key for time series table
    */
    id: TableReadRecord['id'];
    /**
    * Identifier of the sensor
    */
    sensorId: TableReadRecord['sensorId'];
    /**
    * Timestamp of the reading
    */
    timestamp: TableReadRecord['timestamp'];
    /**
    * Temperature reading
    */
    temperature?: TableReadRecord['temperature'];
    /**
    * Humidity reading
    */
    humidity?: TableReadRecord['humidity'];
    /**
    * Pressure reading
    */
    pressure?: TableReadRecord['pressure'];
    /**
    * Array of numeric readings
    */
    readings?: TableReadRecord['readings'];
    /**
    * Whether an anomaly was detected
    */
    anomalyDetected?: TableReadRecord['anomalyDetected'];
    /**
    * Data quality score (1-10)
    */
    dataQuality?: TableReadRecord['dataQuality'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
 * Insert record (casing transformed) for the "public.time_series" table.
 */
export interface TimeSeriesInsertRecord {
    /**
    * Identifier of the sensor
    * @maxLen: 50
    */
    sensorId: TableInsertRecord['sensorId'];
    /**
    * Timestamp of the reading
    */
    timestamp: TableInsertRecord['timestamp'];
    /**
    * Temperature reading
    * @maxLen: 327682
    */
    temperature?: TableInsertRecord['temperature'];
    /**
    * Humidity reading
    * @maxLen: 327682
    */
    humidity?: TableInsertRecord['humidity'];
    /**
    * Pressure reading
    * @maxLen: 458754
    */
    pressure?: TableInsertRecord['pressure'];
    /**
    * Array of numeric readings
    */
    readings?: TableInsertRecord['readings'];
    /**
    * Whether an anomaly was detected
    * @default: false
    */
    anomalyDetected?: TableInsertRecord['anomalyDetected'];
    /**
    * Data quality score (1-10)
    */
    dataQuality?: TableInsertRecord['dataQuality'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
 * Updatable record (casing transformed) for the "public.time_series" table.
 */
export type TimeSeriesUpdateRecord = Partial<TimeSeriesInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/user_sessions/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/user_sessions/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.user_sessions" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const UserSessionsTableBaseSchema = z.object({
     /**
      * dataType: uuid
      * defaultValue: gen_random_uuid()
      */
    id: z.string(),
     /**
      * dataType: int4
      */
    user_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    token_hash: z.string(),
     /**
      * dataType: timestamptz
      */
    expires_at: z.coerce.date(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    last_used_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: inet
      */
    ip_address: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    user_agent: z.string().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.user_sessions" table.
 * This type represents the raw database record without case transforms.
 */
export type UserSessionBaseRecord = z.output<typeof UserSessionsTableBaseSchema>;

/**
 * Read transform for the "public.user_sessions" table.
 * Maps database fields to app case properties.
 */
export const transformUserSessionBaseRecord = (data: UserSessionBaseRecord): {
    id: UserSessionBaseRecord['id'],
    userId?: UserSessionBaseRecord['user_id'],
    tokenHash: UserSessionBaseRecord['token_hash'],
    expiresAt: UserSessionBaseRecord['expires_at'],
    createdAt?: UserSessionBaseRecord['created_at'],
    lastUsedAt?: UserSessionBaseRecord['last_used_at'],
    ipAddress?: UserSessionBaseRecord['ip_address'],
    userAgent?: UserSessionBaseRecord['user_agent'],
} => ({
    id: data.id,
    userId: data.user_id,
    tokenHash: data.token_hash,
    expiresAt: data.expires_at,
    createdAt: data.created_at,
    lastUsedAt: data.last_used_at,
    ipAddress: data.ip_address,
    userAgent: data.user_agent,
});

/**
 * Read schema for the "public.user_sessions" table (after casing transform).
 */
export const UserSessionsTableSchema = UserSessionsTableBaseSchema.transform(transformUserSessionBaseRecord);

/**
 * Base insert/write schema for the "public.user_sessions" table (no casing transforms).
 */
export const UserSessionsTableInsertBaseSchema = z.object({
     /**
      * dataType: uuid
      * defaultValue: gen_random_uuid()
      */
    id: z.string().uuid().optional(),
     /**
      * dataType: int4
      */
    userId: z.number().int().nullable().optional(),
     /**
      * dataType: varchar
      */
    tokenHash: z.string().max(255),
     /**
      * dataType: timestamptz
      */
    expiresAt: z.date(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    lastUsedAt: z.date().nullable().optional(),
     /**
      * dataType: inet
      */
    ipAddress: z.string().nullable().optional(),
     /**
      * dataType: text
      */
    userAgent: z.string().nullable().optional(),
});

/**
 * The base record type for the "public.user_sessions" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type UserSessionInsertBaseRecord = z.output<typeof UserSessionsTableInsertBaseSchema>;

/**
 * The base record type for the "public.user_sessions" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type UserSessionUpdateBaseRecord = Partial<UserSessionInsertBaseRecord>;

/**
 * Insert transform for the "public.user_sessions" table.
 * Maps app cased properties to database fields.
 */
export const transformUserSessionInsertBaseRecord = (data: UserSessionInsertBaseRecord): {
    id?: UserSessionInsertBaseRecord['id'],
    user_id?: UserSessionInsertBaseRecord['userId'],
    token_hash: UserSessionInsertBaseRecord['tokenHash'],
    expires_at: UserSessionInsertBaseRecord['expiresAt'],
    created_at?: UserSessionInsertBaseRecord['createdAt'],
    last_used_at?: UserSessionInsertBaseRecord['lastUsedAt'],
    ip_address?: UserSessionInsertBaseRecord['ipAddress'],
    user_agent?: UserSessionInsertBaseRecord['userAgent'],
} => ({
    id: data.id,
    user_id: data.userId,
    token_hash: data.tokenHash,
    expires_at: data.expiresAt,
    created_at: data.createdAt,
    last_used_at: data.lastUsedAt,
    ip_address: data.ipAddress,
    user_agent: data.userAgent,
});

/**
 * Update transform for the "public.user_sessions" table.
 * Maps app cased properties to database fields.
 */
export const transformUserSessionUpdateBaseRecord = (data: UserSessionUpdateBaseRecord): {
    id?: UserSessionUpdateBaseRecord['id'],
    user_id?: UserSessionUpdateBaseRecord['userId'],
    token_hash: UserSessionUpdateBaseRecord['tokenHash'],
    expires_at: UserSessionUpdateBaseRecord['expiresAt'],
    created_at?: UserSessionUpdateBaseRecord['createdAt'],
    last_used_at?: UserSessionUpdateBaseRecord['lastUsedAt'],
    ip_address?: UserSessionUpdateBaseRecord['ipAddress'],
    user_agent?: UserSessionUpdateBaseRecord['userAgent'],
} => ({
    id: data.id,
    user_id: data.userId,
    token_hash: data.tokenHash,
    expires_at: data.expiresAt,
    created_at: data.createdAt,
    last_used_at: data.lastUsedAt,
    ip_address: data.ipAddress,
    user_agent: data.userAgent,
});

/**
 * Insert schema for the "public.user_sessions" table (after casing transform).
 */
export const UserSessionsTableInsertSchema = UserSessionsTableInsertBaseSchema.transform(transformUserSessionInsertBaseRecord);

/**
 * Update schema for the "public.user_sessions" table (after casing transform).
 */
export const UserSessionsTableUpdateSchema = UserSessionsTableInsertBaseSchema.partial().transform(transformUserSessionUpdateBaseRecord);

type TableInsertRecord = z.input<typeof UserSessionsTableInsertSchema>;
type TableReadRecord = z.output<typeof UserSessionsTableSchema>;

/**
 * Read record (casing transformed) for the "public.user_sessions" table.
 */
export interface UserSessionRecord {
    /**
    * Primary key for user sessions table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the user this session belongs to
    */
    userId?: TableReadRecord['userId'];
    /**
    * Hashed session token
    */
    tokenHash: TableReadRecord['tokenHash'];
    /**
    * Timestamp when the session expires
    */
    expiresAt: TableReadRecord['expiresAt'];
    /**
    * Timestamp when the session was created
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    * Timestamp when the session was last used
    */
    lastUsedAt?: TableReadRecord['lastUsedAt'];
    /**
    * IP address of the client
    */
    ipAddress?: TableReadRecord['ipAddress'];
    /**
    * User agent string of the client
    */
    userAgent?: TableReadRecord['userAgent'];
}

/**
 * Insert record (casing transformed) for the "public.user_sessions" table.
 */
export interface UserSessionInsertRecord {
    /**
    * Primary key for user sessions table
    * @default: gen_random_uuid()
    */
    id?: TableInsertRecord['id'];
    /**
    * ID of the user this session belongs to
    */
    userId?: TableInsertRecord['userId'];
    /**
    * Hashed session token
    * @maxLen: 255
    */
    tokenHash: TableInsertRecord['tokenHash'];
    /**
    * Timestamp when the session expires
    */
    expiresAt: TableInsertRecord['expiresAt'];
    /**
    * Timestamp when the session was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    * Timestamp when the session was last used
    * @default: now()
    */
    lastUsedAt?: TableInsertRecord['lastUsedAt'];
    /**
    * IP address of the client
    */
    ipAddress?: TableInsertRecord['ipAddress'];
    /**
    * User agent string of the client
    */
    userAgent?: TableInsertRecord['userAgent'];
}

/**
 * Updatable record (casing transformed) for the "public.user_sessions" table.
 */
export type UserSessionUpdateRecord = Partial<UserSessionInsertRecord>;

"
`;

exports[`CLI generates correct zod schemas with basic options > tables/users/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > tables/users/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';

export const USER_ROLES = ['admin', 'editor', 'viewer'] as const;

/**
 * Base read schema for the "public.users" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const UsersTableBaseSchema = z.object({
     /**
      * dataType: int4
      * defaultValue: nextval('users_id_seq'::regclass)
      */
    id: z.number(),
     /**
      * dataType: varchar
      */
    name: z.string(),
     /**
      * dataType: varchar
      */
    email: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      * defaultValue: 'active'::character varying
      */
    status: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: jsonb
      */
    profile: z.any().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    created_at: z.coerce.date().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: _text
      */
    roles: z.array(z.enum(USER_ROLES)).nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: _timestamp
      */
    dates: z.array(z.coerce.date()).nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents the raw database record without case transforms.
 */
export type UserBaseRecord = z.output<typeof UsersTableBaseSchema>;

/**
 * Read transform for the "public.users" table.
 * Maps database fields to app case properties.
 */
export const transformUserBaseRecord = (data: UserBaseRecord): {
    id: UserBaseRecord['id'],
    name: UserBaseRecord['name'],
    email?: UserBaseRecord['email'],
    status?: UserBaseRecord['status'],
    profile?: UserBaseRecord['profile'],
    createdAt?: UserBaseRecord['created_at'],
    roles?: UserBaseRecord['roles'],
    dates?: UserBaseRecord['dates'],
} => ({
    id: data.id,
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    createdAt: data.created_at,
    roles: data.roles,
    dates: data.dates,
});

/**
 * Read schema for the "public.users" table (after casing transform).
 */
export const UsersTableSchema = UsersTableBaseSchema.transform(transformUserBaseRecord);

/**
 * Base insert/write schema for the "public.users" table (no casing transforms).
 */
export const UsersTableInsertBaseSchema = z.object({
     /**
      * dataType: varchar
      */
    name: z.string().max(100),
     /**
      * dataType: varchar
      */
    email: z.string().max(255).nullable().optional(),
     /**
      * dataType: varchar
      * defaultValue: 'active'::character varying
      */
    status: z.string().max(20).nullable().optional(),
     /**
      * dataType: jsonb
      */
    profile: z.any().nullable().transform((value) => value ? JSON.stringify(value) : value).optional(),
     /**
      * dataType: timestamptz
      * defaultValue: now()
      */
    createdAt: z.date().nullable().optional(),
     /**
      * dataType: _text
      */
    roles: z.array(z.enum(USER_ROLES)).nullable().optional(),
     /**
      * dataType: _timestamp
      */
    dates: z.array(z.date()).nullable().optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type UserInsertBaseRecord = z.output<typeof UsersTableInsertBaseSchema>;

/**
 * The base record type for the "public.users" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type UserUpdateBaseRecord = Partial<UserInsertBaseRecord>;

/**
 * Insert transform for the "public.users" table.
 * Maps app cased properties to database fields.
 */
export const transformUserInsertBaseRecord = (data: UserInsertBaseRecord): {
    name: UserInsertBaseRecord['name'],
    email?: UserInsertBaseRecord['email'],
    status?: UserInsertBaseRecord['status'],
    profile?: UserInsertBaseRecord['profile'],
    created_at?: UserInsertBaseRecord['createdAt'],
    roles?: UserInsertBaseRecord['roles'],
    dates?: UserInsertBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * Update transform for the "public.users" table.
 * Maps app cased properties to database fields.
 */
export const transformUserUpdateBaseRecord = (data: UserUpdateBaseRecord): {
    name: UserUpdateBaseRecord['name'],
    email?: UserUpdateBaseRecord['email'],
    status?: UserUpdateBaseRecord['status'],
    profile?: UserUpdateBaseRecord['profile'],
    created_at?: UserUpdateBaseRecord['createdAt'],
    roles?: UserUpdateBaseRecord['roles'],
    dates?: UserUpdateBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * Insert schema for the "public.users" table (after casing transform).
 */
export const UsersTableInsertSchema = UsersTableInsertBaseSchema.transform(transformUserInsertBaseRecord);

/**
 * Update schema for the "public.users" table (after casing transform).
 */
export const UsersTableUpdateSchema = UsersTableInsertBaseSchema.partial().transform(transformUserUpdateBaseRecord);

type TableInsertRecord = z.input<typeof UsersTableInsertSchema>;
type TableReadRecord = z.output<typeof UsersTableSchema>;

/**
 * Read record (casing transformed) for the "public.users" table.
 */
export interface UserRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    name: TableReadRecord['name'];
    /**
    */
    email?: TableReadRecord['email'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    */
    profile?: TableReadRecord['profile'];
    /**
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    */
    roles?: TableReadRecord['roles'];
    /**
    */
    dates?: TableReadRecord['dates'];
}

/**
 * Insert record (casing transformed) for the "public.users" table.
 */
export interface UserInsertRecord {
    /**
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * @maxLen: 255
    */
    email?: TableInsertRecord['email'];
    /**
    * @maxLen: 20
    * @default: 'active'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    */
    profile?: TableInsertRecord['profile'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    */
    roles?: TableInsertRecord['roles'];
    /**
    */
    dates?: TableInsertRecord['dates'];
}

/**
 * Updatable record (casing transformed) for the "public.users" table.
 */
export type UserUpdateRecord = Partial<UserInsertRecord>;

export type UserRole = (typeof USER_ROLES)[number];
"
`;

exports[`CLI generates correct zod schemas with basic options > types.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export type Table = 
    | 'audit_logs'
    | 'categories'
    | 'comments'
    | 'constraint_variations'
    | 'enum_tests'
    | 'files'
    | 'geographic_data'
    | 'inventory'
    | 'network_logs'
    | 'order_items'
    | 'orders'
    | 'post_categories'
    | 'posts'
    | 'products'
    | 'time_series'
    | 'user_sessions'
    | 'users'

export type Views = 
    | 'view_user_posts'

export type MaterializedViews = 
    | 'mv_user_posts'
"
`;

exports[`CLI generates correct zod schemas with basic options > views/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './view_user_posts/index.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > views/view_user_posts/index.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI generates correct zod schemas with basic options > views/view_user_posts/schema.ts 1`] = `
"// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from 'zod';


/**
 * Base read schema for the "public.view_user_posts" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const ViewUserPostsBaseSchema = z.object({
     /**
      * dataType: int4
      */
    user_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: varchar
      */
    user_name: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: int4
      */
    post_id: z.number().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    post_title: z.string().nullable().transform((value) => value ?? undefined).optional(),
     /**
      * dataType: text
      */
    post_content: z.string().nullable().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.view_user_posts" table.
 * This type represents the raw database record without case transforms.
 */
export type ViewUserPostBaseRecord = z.output<typeof ViewUserPostsBaseSchema>;

/**
 * Read transform for the "public.view_user_posts" table.
 * Maps database fields to app case properties.
 */
export const transformViewUserPostBaseRecord = (data: ViewUserPostBaseRecord): {
    userId?: ViewUserPostBaseRecord['user_id'],
    userName?: ViewUserPostBaseRecord['user_name'],
    postId?: ViewUserPostBaseRecord['post_id'],
    postTitle?: ViewUserPostBaseRecord['post_title'],
    postContent?: ViewUserPostBaseRecord['post_content'],
} => ({
    userId: data.user_id,
    userName: data.user_name,
    postId: data.post_id,
    postTitle: data.post_title,
    postContent: data.post_content,
});

/**
 * Read schema for the "public.view_user_posts" table (after casing transform).
 */
export const ViewUserPostsSchema = ViewUserPostsBaseSchema.transform(transformViewUserPostBaseRecord);

type TableReadRecord = z.output<typeof ViewUserPostsSchema>;

/**
 * Read record (casing transformed) for the "public.view_user_posts" view.
 */
export interface ViewUserPostRecord {
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    userName?: TableReadRecord['userName'];
    /**
    */
    postId?: TableReadRecord['postId'];
    /**
    */
    postTitle?: TableReadRecord['postTitle'];
    /**
    */
    postContent?: TableReadRecord['postContent'];
}

"
`;
